{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"spring cloud zuul网关的作用","slug":"框架","date":"2019-07-12T14:29:09.000Z","updated":"2019-07-12T15:50:11.803Z","comments":true,"path":"2019/07/12/框架/","link":"","permalink":"http://yoursite.com/2019/07/12/框架/","excerpt":"","text":"spring cloud zuul网关的作用1是类似于Nginx的网址重定向,但zuul的重定向的一般是整个spring cloud里在Eureka注册中心的模块. 2、zuul更重要的功能为过滤请求. solr如何实现搜索的？倒排索引，先抽取文档中词，并建立词与文档id的映射关系，然后查询的时候会根据词去查询文档id，并查询出文档 倒排索引源于实际应用中需要根据属性的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。 solr的索引查询为什么比数据库要快Solr使用的是Lucene API实现的全文检索。全文检索本质上是查询的索引。而数据库中并不是所有的字段都建立的索引，更何况如果使用like查询时很大的可能是不使用索引，所以使用solr查询时要比查数据库快","categories":[],"tags":[],"keywords":[]},{"title":"小兵","slug":"小兵","date":"2019-07-12T14:29:09.000Z","updated":"2019-07-12T14:34:39.341Z","comments":true,"path":"2019/07/12/小兵/","link":"","permalink":"http://yoursite.com/2019/07/12/小兵/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"面向对象特性：继承 封装 多态 抽象","slug":"javase","date":"2019-07-12T14:29:09.000Z","updated":"2019-07-12T15:52:54.156Z","comments":true,"path":"2019/07/12/javase/","link":"","permalink":"http://yoursite.com/2019/07/12/javase/","excerpt":"","text":"面向对象特性：继承 封装 多态 抽象 基本数据类型：整型、浮点、字符、布尔 引用类型：String等 int范围： 12341、java中int的取值范围为-2147483648到+-2147483648。2、首先jdk中定义int占4个字节32位，32位就是jvm仅仅给分配32个格子的空间，用以存放数据。3、计算机中用0和1存放数据。那么，32个格子中放满0或1的方法，有2的32次方种。4、但是java中int有正负之分，所以32个格子中占用一个格子标识正负，仅仅能用31个格子来标识数值。最后int能标识的最大/最小数字是：2的31次方即+/- 2147483648。取值范围即为二者之间。 集合 List 和 Set 是存储单列数据的集合，Map 是存储键和值这样的双列数据的集合；List 中存储的数据是有顺序，并且允许重复；Map 中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的，Set 中存储的数据是无序的，且不允许有重复，但元素在集合中的位置由元素的 hashcode 决定，位置是固定的（Set 集合根据 hashcode 来进行数据的存储，所以位置是固定的，但是位置不是用户可以控制的，所以对于用户来说 set 中的元素还是无序的） List接口下实现类： 1234567LinkedList：基于链表实现，链表增删快，查找慢ArrayList：：基于数组实现，非线程安全的，效率高，便于索引，但不便于插入删除Vector：基于数组实现，线程安全的，效率低ArrayList 底层结构是数组,底层查询快,增删慢。LinkedList 底层结构是链表型的,增删快,查询慢。voctor 底层结构是数组 线程安全的,增删慢,查询慢。 Map： 1234HashMap：基于 hash 表的 Map 接口实现，非线程安全，高效，支持 null键值；HashTable：线程安全，低效，不支持 null 值和 null 键；LinkedHashMap：是 HashMap 的一个子类，保存了记录的插入顺序ConcurrentHashMap：HashTable的替代品，ConcurrentHashMap与HashTable都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。 Set 接口： 12HashSet：底层是由HashMap实现，不允许集合中有重复的值，使用该方式时需要重写 equals()和 hashCode()方法LinkedHashSet：继承与 HashSet，同时又基于 LinkedHashMap 来进行实现，底层使用的是 LinkedHashMap） List a=new ArrayList()和 ArrayList a =new ArrayList()的区别1List list = new ArrayList();这句创建了一个ArrayList的对象后把上溯到了List。此时它是一个 List 对象了，有些ArrayList 有但是 List 没有的属性和方法，它就不能再用了。而 ArrayList list=new ArrayList();创建一对象则保留了ArrayList 的所有属性。 所以需要用到 ArrayList 独有的方法的时候不能用前者 Java 中 ArrayList 和 Linkedlist 区别多系统服务器交互1、两个项目同时访问一个数据库的中间库，触发器分发数据库到项目数据库中 2、使用webservice接口实现 Oracle中存储过程优点：存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般SQL语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。当对数据库进行复杂操作时(如对多个表进行Update、Insert、Query、Delete时），可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。3.存储过程可以重复使用,可减少数据库开发人员的工作量。4.安全性高,可设定只有某用户才具有对指定存储过程的使用权。 类与接口区别1234561、接口类似于类，但接口的成员都没有执行方式，它只是方法、属性、事件和索引的组合而已，并且也只能包含这四种成员；类除了这四种成员之外还可以有别的成员(如字段)。2、不能实例化一个接口，接口只包括成员的签名；而类可以实例化(abstract类除外)。3、接口没有构造函数，类有构造函数。4、接口不能进行运算符的重载，类可以进行运算符重载。5、接口的成员没有任何修饰符，其成员总是公共的，而类的成员则可以有修饰符(如：虚拟或者静态)。6、派生于接口的类必须实现接口中所有成员的执行方式，而从类派生则不然。 获取日期时间1234567891011121314Calendar cal = Calendar.getInstance(); //获取日历实例System.out.println(cal.get(Calendar.YEAR));System.out.println(cal.get(Calendar.MONTH)); // 0 - 11System.out.println(cal.getTime()); //获取当前时间 格式化// Java 8LocalDateTime dt = LocalDateTime.now(); //通过LDT now()方法获取当前时间实例System.out.println(dt.getYear()); System.out.println(dt.getMonthValue()); // 1 - 12System.out.println(dt.getDayOfMonth());System.out.println(dt.getHour());System.out.println(Clock.systemDefaultZone().millis()); //当前时间戳System.out.println(Clock.systemDefaultZone().getZone()); //获取时区 如何将一个 java 对象序列化到文件里12345678910111. //对象输出流2. ObjectOutputStream objectOutputStream = 3. new ObjectOutputStream(new FileOutputStream(new File(\"D://obj\")));4. objectOutputStream.writeObject(new User(\"zhangsan\", 100));5. objectOutputStream.close();6. //对象输入流7. ObjectInputStream objectInputStream = 8. new ObjectInputStream(new FileInputStream(new File(\"D://obj\")));9. User user = (User)objectInputStream.readObject();10. System.out.println(user);11. objectInputStream.close(); java导出excel图表等POI开源组件实现将数据导出到Excel文件中 如果 cookie 被禁用了怎么办保持登录的关键不是 cookie，而是通过cookie 保存和传输的 session ID，其本质是能获取用户信息的数据。除了 cookie，还通常使用 HTTP 请求头来传输。但是这个请求头浏览器不会像 cookie 一样自动携带，需要手工处理 设计模式1234创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式 单例设计模式123456789饿汉式：// 直接创建对象// 私有化构造函数// 返回对象实例懒汉式：// 声明变量// 私有构造函数// 提供对外方法 工厂方法模式1234工厂方法模式分为三种：普通工厂模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。多个工厂方法模式，是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可","categories":[],"tags":[],"keywords":[]},{"title":"Maven 软件的安装","slug":"maven仓库与tomcat","date":"2019-07-12T14:29:09.000Z","updated":"2019-07-12T14:35:10.098Z","comments":true,"path":"2019/07/12/maven仓库与tomcat/","link":"","permalink":"http://yoursite.com/2019/07/12/maven仓库与tomcat/","excerpt":"","text":"Maven 软件的安装Apache-maven-3.5.2 下载地址：http://archive.apache.org/dist/maven/maven-3/ Maven 下载后，将 Maven 解压到一个没有中文没有空格的路径下，比如 D:\\software\\maven 下面。解压后目录结构如下： 12345bin:存放了 maven 的命令，比如我们前面用到的 mvn tomcat:runboot:存放了一些 maven 本身的引导程序，如类加载器等conf:存放了 maven 的一些配置文件，如 setting.xml 文件lib:存放了 maven 本身运行所需的一些 jar 包至此我们的 maven 软件就可以使用了，前提是你的电脑上之前已经安装并配置好了 JDK。 Maven 及 JDK 配置配置 MAVEN_HOME ，变量值就是你的 maven 安装 的路径（bin 目录之前一级目录） 同时不要忘记在Path中添加环境变量 1%MAVEN_HOME%\\bin Maven 软件版本测试通过命令行 mvn -v命令检查 maven 是否安装成功，看到 maven 的版本为 3.5.2 及 java 版本为 1.8 即为安装成功。 Maven 仓库的分类123456789本地仓库 ：用来存储从远程仓库或中央仓库下载的插件和 jar 包，项目使用一些插件或 jar 包，优先从本地仓库查找默认本地仓库位置在 $&#123;user.dir&#125;/.m2/repository，$&#123;user.dir&#125;表示 windows 用户目录。远程仓库：如果本地需要插件或者 jar 包，本地仓库没有，默认去远程仓库下载。远程仓库可以在互联网内也可以在局域网内。中央仓库 ：在 maven 软件中内置一个远程仓库地址 http://repo1.maven.org/maven2 ，它是中央仓库，服务于整个互联网，它是由 Maven 团队自己维护，里面存储了非常全的 jar 包，它包含了世界上大部分流行的开源项目构件 Maven 本地仓库的配置将已下载本地仓库 “repository.rar”解压至自己的电脑上，我们解压在 D:\\repository 目录下（可以放在没有中文及空格的目录下）。 在 MAVE_HOME/conf/settings.xml 文件中配置本地仓库位置（maven 的安装目录下）打开 settings.xml文件，配置如下： 全局 setting 与用户 settingmaven 仓库地址、私服等配置信息需要在 setting.xml 文件中配置，分为全局配置和用户配置。在 maven 安装目录下的有 conf/setting.xml 文件，此 setting.xml 文件用于 maven 的所有 project项目，它作为 maven 的全局配置。如需要个性配置则需要在用户配置中设置，用户配置的 setting.xml 文件默认的位置在：${user.dir}/.m2/settings.xml 目录中,${user.dir} 指 windows 中的用户目录。maven 会先找用户配置，如果找到则以用户配置文件为准，否则使用全局配置文件 idea 的 maven 配置打开File&gt;Settings 配置 maven选择本地 maven 安装目录，指定 maven 安装目录下 conf 文件夹中 settings 配置文件。 创建项目时这些不用改 坐标的来源方式从互联网搜索http://search.maven.org/http://mvnrepository.com/ 依赖范围compile：编译范围，指 A 在编译时依赖 B，此范围为默认依赖范围。编译范围的依赖会用在编译、测试、运行，由于运行时需要所以编译范围的依赖会被打包。 provided：provided 依赖只有在当 JDK 或者一个容器已提供该依赖之后才使用， provided 依赖在编译和测试时需要，在运行时不需要，比如：servlet api 被 tomcat 容器提供。 runtime：runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如：jdbc的驱动包。由于运行时需要所以 runtime 范围的依赖会被打包。 test：test 范围依赖 在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用，比如：junit。由于运行时不需要所以 test范围依赖不会被打包。 system：system 范围依赖与 provided 类似，但是你必须显式的提供一个对于本地系统中 JAR文件的路径，需要指定 systemPath 磁盘路径，system依赖不推荐使用。 TOMCAT解压即可使用，配置文件在D:\\apache-tomcat\\apache-tomcat-8.5.31\\conf中","categories":[],"tags":[],"keywords":[]},{"title":"hello","slug":"hello","date":"2019-02-14T17:02:38.000Z","updated":"2019-02-14T17:02:38.090Z","comments":true,"path":"2019/02/15/hello/","link":"","permalink":"http://yoursite.com/2019/02/15/hello/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"vmware安装与激活","date":"2019-02-14T17:00:49.055Z","updated":"2018-11-13T07:46:37.619Z","comments":true,"path":"2019/02/15/vmware安装与激活/","link":"","permalink":"http://yoursite.com/2019/02/15/vmware安装与激活/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"idea环境配置","date":"2019-02-14T17:00:49.006Z","updated":"2018-12-13T12:19:14.973Z","comments":true,"path":"2019/02/15/idea环境配置/","link":"","permalink":"http://yoursite.com/2019/02/15/idea环境配置/","excerpt":"","text":"安装与环境正常安装，选择电脑位数版本 首次不导入设置 创建工程设置sdk选择 Create New Project,点击 new 按钮，配置安装的 JDK版本,选择 JDK目录，点击确定 一直下一步，创建项目名 IDEA的工作界面，我们的项目已经创建好了，如果再新建项目，点击 File-&gt;new-&gt;Project 字体设置点击菜单栏上的 File-&gt;Settings-&gt;Editor-&gt;Font 修改字体。 项目目录.idea 目录和 demo.iml 和我们开发无关，是IDEA工具自己使用的out 目录是存储编译后的.class文件src 目录是存储我们编写的.java源文件 Maven配置设置maven仓库 其他配置配置编码 配置jdk 配置快捷键可以选择模板，自定义请先copy个副本 设置idea导入包（多个同名的类调用不同的包，必须自己手动Alt+Enter设置） 自定义自己代码模板 提示忽略大小写默认idea设置是区分大小写的，可以设置关闭 配置虚拟机内存123456修改idea64.exe.vmoptions（64位电脑选择此文件）一个例子，电脑内存8G，设置如下：-Xms1024m-Xmx4096m-XX:MaxPermSize=1024m-XX:ReservedCodeCacheSize=1024m 设置配置编码问题修改idea64.exe.vmoptions 1-Dfile.encoding=UTF8 IDEA常用快捷键12345678910快捷键 功能Alt+Enter 导入包，自动修正代码Ctrl+Y 删除光标所在行Ctrl+D 复制光标所在行的内容，插入光标位置下面Ctrl+Alt+L 格式化代码Ctrl+/ 单行注释Ctrl+Shift+/ 选中代码注释，多行注释，再按取消注释Alt+Ins 自动生成代码，toString，get，set等方法Alt+Shift+上下箭头 移动当前代码行Ctrl+空格 补全代码 自定义设置快捷键部分快捷键冲突，例如Ctrl+空格，因此需要手动修改 File-&gt;Settings-&gt;keymap-&gt;Main menu-&gt;code-&gt;Completion-&gt;Basic 双击 Basic-&gt;remove-&gt;Ctrl+空格再次双击 Basic-&gt;Add Keyboard-&gt;键入 Alt+/-&gt;点击OK","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"Vue","date":"2019-02-14T16:54:38.211Z","updated":"2018-12-13T12:19:22.679Z","comments":true,"path":"2019/02/15/Vue/","link":"","permalink":"http://yoursite.com/2019/02/15/Vue/","excerpt":"","text":"Vue1 vue简介Vue (读音 /vju/，类似于 view) 是一套用于构建用户界面的渐进式框架。和AngularJS的语法非常的相似。 Vue 的一些语法和 AngularJS 的很相似 (例如 v-if vs ng-if)。因为 AngularJS 是 Vue 早期开发的灵感来源。然而，AngularJS 中存在的许多问题，在 Vue 中已经得到解决。 1.1 MVVM模式MVVM模式： M ： Model (数据) V ：View（视图）–静态页面 VM ：vue 的实例 1234567const vm = new Vue(&#123; // this ---》 当前的 VM的实例 el:\"#id\", // id任意即可 data:&#123; message:\"hello...\" &#125;&#125;) 2 Vue常用的指令2.1 插值表达式1&#123;&#123; message &#125;&#125; // 表达式内可以 写算术运算， 调用vue的方法， 但是不可以定义 js的变量等 2.2 v-onv-on:click , v-on:keydown 和原生js 一样的，vue给我们提供简写的方式 @click, 绑定事件的处理 2.3 v-text 和 v-html 和 v-bindv-text: 绑定的数据是文本 v-html: 显示带HTML代码的数据， 也可以显示存文本 v-bind: 强制绑定HTML标签的属性上， 简写： 如：v-bind:href=”url” ， 简写 :href=”url” 简写: 2.4 v-model绑定表单中得HTML的变量 你可以用 v-model 指令在表单 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt; 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 2.5 v-forv-for： 循环遍历 ， 字符串数组， 遍历对象， 集合… es6中要加冒号后面写唯一值即可 1v-for=\"(item, index) in list \" :key=\"index\" 2.6 v-if 和 v-show判断是否显示当前的变量的值， 如果条件成立，显示， 否则不显示 3 Vue生命周期 8个分为三大类： 初始化方法（四个）只会调用一次 更新显示（循环） 销毁VM实例 4 axios异步调用参考官网","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"nodeJS","date":"2019-02-14T16:54:38.183Z","updated":"2018-11-12T11:52:19.000Z","comments":true,"path":"2019/02/15/nodeJS/","link":"","permalink":"http://yoursite.com/2019/02/15/nodeJS/","excerpt":"","text":"第1章 NodeJS1 学习目标： 掌握Node.js基本使用方法，理解模块化编程 掌握包资源管理器NPM的使用 说出webpack的作用 掌握ES6常用的新特性语法 2 Node.js2.1 什么是Node.js简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 2.2 Node.js安装1、下载对应你系统的Node.js版本: https://nodejs.org/en/download/ （我们现在使用的版本是v9.4.0，资源中也已提供）2、选安装目录进行安装 默认即可 3.测试 在命令提示符下输入命令 1node -v 会显示当前node的版本 2.3 快速入门2.3.1 控制台输出我们现在做个最简单的小例子，演示如何在控制台输出，创建文本文件demo1.js,代码内容 123var a=1;var b=2;console.log(a+b); 我们在命令提示符下输入命令 1node demo1.js 2.3.2 使用函数创建文本文件demo2.js 12345var c=add(100,200);console.log(c);function add(a,b)&#123; return a+b;&#125; 命令提示符输入命令 1node demo2.js 运行后看到输出结果为300 2.3.3 模块化编程创建文本文件demo3_1.js 123exports.add=function(a,b)&#123; return a+b;&#125; 创建文本文件demo3_2.js，3.1赋值给demo然后直接调用 12var demo= require('./demo3_1');console.log(demo.add(400,600)); 我们在命令提示符下输入命令 1node demo3_2.js 结果为1000 2.3.4 创建web服务器创建文本文件demo4.js 1234567891011var http = require('http');http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 发送响应数据 \"Hello World\" response.end('Hello World\\n');&#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); http为node内置的web模块 我们在命令提示符下输入命令 1node demo4.js 服务启动后，我们打开浏览器，输入网址 \u0003http://localhost:8888/ 即可看到网页输出结果Hello World 心情是不是很激动呢？Ctrl+c 终止运行。 2.3.5 理解服务端渲染我们创建demo5.js ，将上边的例子写成循环的形式 1234567891011121314var http = require('http');http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 发送响应数据 \"Hello World\" for(var i=0;i&lt;10;i++)&#123; response.write('Hello World\\n'); &#125; response.end(''); &#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 我们在命令提示符下输入命令启动服务 1node demo5.js 浏览器地址栏输入http://127.0.0.1:8888即可看到查询结果。 我们右键“查看源代码”发现，并没有我们写的for循环语句，而是直接的10条Hello World ，这就说明这个循环是在服务端完成的，而非浏览器（客户端）来完成。这与我们原来的JSP很是相似。 2.3.6 接收参数创建demo6.js 1234567891011var http = require('http');var url = require('url');http.createServer(function(request, response)&#123; response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 解析 url 参数 var params = url.parse(request.url, true).query; response.write(\"name:\" + params.name); response.write(\"\\n\"); response.end();&#125;).listen(8888);console.log('Server running at http://127.0.0.1:8888/'); 我们在命令提示符下输入命令 1node demo6.js 在浏览器测试结果 3 包资源管理器NPM3.1 什么是NPMnpm全称Node Package Manager，他是node包管理和分发工具。其实我们可以把NPM理解为前端的Maven 我们通过npm 可以很方便地下载js库，管理前端工程. 最新版本的node.js已经集成了npm工具，在命令提示符输入 npm -v 可查看当前npm版本 3.2 NPM命令3.2.1 初始化工程init命令是工程初始化命令。 建立一个空文件夹，在命令提示符进入该文件夹 执行命令初始化 1npm init 按照提示输入相关信息，如果是用默认值则直接回车即可。 name: 项目名称 version: 项目版本号 description: 项目描述 keywords: {Array}关键词，便于用户搜索到我们的项目 最后会生成package.json文件，这个是包的配置文件，相当于maven的pom.xml 我们之后也可以根据需要进行修改。 3.2.2 本地安装install命令用于安装某个模块，如果我们想安装express模块（node的web框架），输出命令如下： 1npm install express 出现黄色的是警告信息，可以忽略，请放心，你已经成功执行了该命令。 在该目录下已经出现了一个node_modules文件夹 和package-lock.json node_modules文件夹用于存放下载的js库（相当于maven的本地仓库） package-lock.json是当 node_modules 或 package.json 发生变化时自动生成的文件。这个文件主要功能是确定当前安装的包的依赖，以便后续重新安装的时候生成相同的依赖，而忽略项目开发过程中有些依赖已经发生的更新。 我们再打开package.json文件，发现刚才下载的express已经添加到依赖列表中了. 关于版本号定义： 1234567指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。latest：安装最新版本。 3.2.3 全局安装刚才我们使用的是本地安装，会将js库安装在当前目录，而使用全局安装会将库安装到你的全局目录下。 如果你不知道你的全局目录在哪里，执行命令 1npm root -g 我的全局目录在 C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules 比如我们全局安装jquery, 输入以下命令 1npm install jquery -g 3.2.4 批量下载我们从网上下载某些代码，发现只有package.json,没有node_modules文件夹，这时我们需要通过命令重新下载这些js库. 进入目录（package.json所在的目录）输入命令 1npm install 此时，npm会自动下载package.json中依赖的js库. 3.2.5淘宝NPM镜像【建议使用】有时我们使用npm下载资源会很慢，所以我们可以安装一个cnmp(淘宝镜像)来加快下载速度。 输入命令，进行全局安装淘宝镜像。 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装后，我们可以使用以下命令来查看cnpm的版本 1cnpm -v 使用cnpm 1cnpm install 需要下载的js库 3.2.6 运行工程如果我们想运行某个工程，则使用run命令 如果package.json中定义的脚本如下 dev是开发阶段测试运行 build是构建编译工程 lint 是运行js代码检测 我们现在来试一下运行dev 1npm run dev 3.2.7 编译工程我们接下来，测试一个代码的编译.编译后我们就可以将工程部署到nginx中啦~ 编译后的代码会放在dist文件夹中，首先我们先删除dist文件夹中的文件,进入命令提示符输入命令 1npm run build 生成后我们会发现只有个静态页面，和一个static文件夹 这种工程我们称之为单页Web应用（single page web application，SPA），就是只有一张Web页面的应用，是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。 这里其实是调用了webpack来实现打包的，关于webpack我们后续的章节进行介绍 4 Webpack4.1 什么是Webpack​ Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 ​ 从图中我们可以看出，Webpack 可以将多种静态资源 js、css、less 转换成一个静态文件，减少了页面的请求。 接下来我们简单为大家介绍 Webpack 的安装与使用 4.2 Webpack安装全局安装 12npm install webpack -gnpm install webpack-cli -g 安装后查看版本号 1webpack -v 4.3 快速入门4.3.1 JS打包（1）创建src文件夹，创建bar.js 传入什么输出什么 123exports.info=function(str)&#123; document.write(str);&#125; （2）src下创建logic.js 计算两数字之和 123exports.add=function(a,b)&#123; return a+b;&#125; （3）src下创建main.js 123var bar= require('./bar');var logic= require('./logic');bar.info( 'Hello world!'+ logic.add(100,200)); （4）创建配置文件webpack.config.js ，该文件与src处于同级目录 12345678var path = require(\"path\");module.exports = &#123; entry: './src/main.js', output: &#123; path: path.resolve(__dirname, './dist'), filename: 'bundle.js' &#125;&#125;; 以上代码的意思是：读取当前目录下src文件夹中的main.js（入口文件）内容，把对应的js文件打包，打包后的文件放入当前目录的dist文件夹下，打包后的js文件名为bundle.js （5）执行编译命令 1webpack 执行后查看bundle.js 会发现里面包含了上面两个js文件的内容 （7）创建index.html ,引用bundle.js 12345678&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"dist/bundle.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 测试调用index.html，会发现有内容输出 4.3.2 CSS打包（1）安装style-loader和 css-loader Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。 Loader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 require 来加载任何类型的模块或文件，比如 CoffeeScript、 JSX、 LESS 或图片。首先我们需要安装相关Loader插件，css-loader 是将 css 装载到 javascript；style-loader 是让 javascript 认识css 1cnpm install style-loader css-loader --save-dev （2）修改webpack.config.js 12345678910111213141516var path = require(\"path\");module.exports = &#123; entry: './src/main.js', output: &#123; path: path.resolve(__dirname, './dist'), filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125; ] &#125;&#125;; （3）在src文件夹创建css文件夹,css文件夹下创建css1 123body&#123; background:red;&#125; （4）修改main.js ，引入css1.css 1require(&apos;./css1.css&apos;); （5）重新运行webpack （6）运行index.html看看背景是不是变成红色啦？ 5 ES65.1 什么是ES6编程语言JavaScript是ECMAScript的实现和扩展 。ECMAScript是由ECMA（一个类似W3C的标准组织）参与进行标准化的语法规范。ECMAScript定义了： 语言语法 – 语法解析规则、关键字、语句、声明、运算符等。 类型 – 布尔型、数字、字符串、对象等。 原型和继承 内建对象和函数的标准库 – JSON、Math、数组方法、对象自省方法等。 ECMAScript标准不定义HTML或CSS的相关功能，也不定义类似DOM（文档对象模型）的Web API，这些都在独立的标准中进行定义。ECMAScript涵盖了各种环境中JS的使用场景，无论是浏览器环境还是类似node.js的非浏览器环境。 ECMAScript标准的历史版本分别是1、2、3、5。 那么为什么没有第4版？其实，在过去确实曾计划发布提出巨量新特性的第4版，但最终却因想法太过激进而惨遭废除（这一版标准中曾经有一个极其复杂的支持泛型和类型推断的内建静态类型系统）。 ES4饱受争议，当标准委员会最终停止开发ES4时，其成员同意发布一个相对谦和的ES5版本，随后继续制定一些更具实质性的新特性。这一明确的协商协议最终命名为“Harmony”，因此，ES5规范中包含这样两句话 ECMAScript是一门充满活力的语言，并在不断进化中。 未来版本的规范中将持续进行重要的技术改进 2009年发布的改进版本ES5，引入了Object.create()、Object.defineProperty()、getters和setters、严格模式以及JSON对象。 ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，2015年6月正式发布。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 5.2 Node.js中使用ES6ES6+ 太棒了,但是很多高级功能node是不支持的,就需要使用babel转换成ES5 （1）babel转换配置,项目根目录添加.babelrc 文件 123&#123; \"presets\" : ['es2015']&#125; （2）安装es6转换模块 1cnpm install babel-preset-es2015 --save-dev （3）全局安装命令行工具 1cnpm install babel-cli -g （4）使用 1babel-node js文件名 5.3 语法新特性5.3.1 变量声明let【重要】我们都是知道在ES6以前，var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部(不在函数内即在全局作用域的最顶部)。这就是函数变量提升例如 1234567function aa() &#123; if(bool) &#123; var test = 'hello man' &#125; else &#123; console.log(test) &#125;&#125; 以上的代码实际上是: 12345678910function aa() &#123; var test // 变量提升 if(bool) &#123; test = 'hello man' &#125; else &#123; //此处访问test 值为undefined console.log(test) &#125; //此处访问test 值为undefined &#125; 所以不用关心bool是否为true or false。实际上，无论如何test都会被创建声明。 接下来ES6主角登场： 我们通常用let和const来声明，let表示变量、const表示常量。let和const都是块级作用域。怎么理解这个块级作用域？在一个函数内部 ，在一个代码块内部。看以下代码 12345678function aa() &#123; if(bool) &#123; let test = 'hello man' &#125; else &#123; //test 在此处访问不到 console.log(test) &#125; &#125; 5.3.2 常量声明const 用于声明常量，看以下代码 12const name = 'lux'name = 'joe' //再次赋值此时会报错 5.3.3 模板字符串es6模板字符简直是开发者的福音啊，解决了ES5在字符串功能上的痛点。 第一个用途，基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定。 123456//es5 var name = 'lux'console.log('hello' + name )//es6const name = 'lux'console.log(`hello $&#123;name&#125;`) //hello lux 第二个用途，在ES5时我们通过反斜杠()来做多行字符串或者字符串一行行拼接。ES6反引号()直接搞定。 1234567// es5var msg = \"Hi \\man!\"// es6const template = `&lt;div&gt; &lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;` 5.3.4 函数默认参数ES6为参数提供了默认值。在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。 看例子代码 12345function action(num = 200) &#123; console.log(num)&#125;action() //200action(300) //300 5.3.5 箭头函数【重点】ES6很有意思的一部分就是函数的快捷写法。也就是箭头函数。 箭头函数最直观的三个特点。 1不需要function关键字来创建函数 2省略return关键字 3继承当前上下文的 this 关键字 看下面代码（ES6） 123(response,message) =&gt; &#123; .......&#125; 相当于ES5代码 123function(response,message)&#123; ......&#125; 5.3.6 对象初始化简写ES5我们对于对象都是以键值对的形式书写，是有可能出现键值对重名的。例如 123456function people(name, age) &#123; return &#123; name: name, age: age &#125;; &#125; 以上代码可以简写为 123456function people(name, age) &#123; return &#123; name, age &#125;; &#125; 5.3.7 解构数组和对象是JS中最常用也是最重要表示形式。为了简化提取信息，ES6新增了解构，这是将一个数据结构分解为更小的部分的过程 ES5我们提取对象中的信息形式如下 1234567const people = &#123; name: 'lux', age: 20&#125;const name = people.nameconst age = people.ageconsole.log(name + ' --- ' + age) 是不是觉得很熟悉，没错，在ES6之前我们就是这样获取对象信息的，一个一个获取。现在，ES6的解构能让我们从对象或者数组里取出数据存为变量，例如 123456789101112//对象 const people = &#123; name: 'lux', age: 20 &#125; const &#123; name, age &#125; = people console.log(`$&#123;name&#125; --- $&#123;age&#125;`) //数组 const color = ['red', 'blue'] const [first, second] = color console.log(first) //'red' console.log(second) //'blue' 5.3.8 Spread OperatorES6中另外一个好玩的特性就是Spread Operator 也是三个点儿…接下来就展示一下它的用途。 组装对象或者数组 123456789//数组const color = ['red', 'yellow']const colorful = [...color, 'green', 'pink']console.log(colorful) //[red, yellow, green, pink]//对象const alp = &#123; fist: 'a', second: 'b'&#125;const alphabets = &#123; ...alp, third: 'c' &#125;console.log(alphabets) //&#123; \"fist\": \"a\", \"second\": \"b\", \"third\": \"c\" 5.3.9 import 和 export【重点】import导入模块、export导出模块 lib.js 123456789101112131415161718let fn0=function()&#123; console.log('fn0...');&#125;export &#123;fn0&#125;let dele=function()&#123; console.log('dele...');&#125;export &#123;dele&#125;// 还可以写成export default &#123; fn0()&#123; console.log('fn0...'); &#125;, dele()&#123; // .... &#125;&#125; demo9.js 1234567891011import &#123;fn0&#125; from './lib'import &#123;dele&#125; from './lib'fn0();// 还可以写成// 1.import * as jsApi from './lib.js' // 后缀可以省略jsApi.info()jsApi.dele()// 2.import jsApi from './lib.js' // 使用这种方式 ，必须要使用export default &#123;&#125; 导出 注意：node(v8.x)本身并不支持import关键字，所以我们需要使用babel的命令行工具来执行（配置详见6.2小节内容） 1babel-node demo9 5.3.10 Promise（自学内容）​ Promise 是异步编程的一种解决方案，比传统的解决方案–回调函数和事件－－更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了语法，原生提供了Promise. ​ 此知识点属于本章自学内容，请同学们百度promise查阅文章完成自学（完成测试代码，整理自学笔记）。","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"Java日志文件的八个级别","date":"2019-02-14T16:54:38.135Z","updated":"2018-11-25T08:22:10.143Z","comments":true,"path":"2019/02/15/Java日志文件的八个级别/","link":"","permalink":"http://yoursite.com/2019/02/15/Java日志文件的八个级别/","excerpt":"","text":"通常： 项目开发阶段用Info，运营阶段用Error 详细： log4j定义了8个级别的log（除去OFF和ALL，可以说分为6个级别），优先级从高到低依次为：OFF、FATAL、ERROR、WARN、INFO、DEBUG、TRACE、 ALL。 ALL 最低等级的，用于打开所有日志记录。 TRACE designates finer-grained informational events than the DEBUG.Since:1.2.12，很低的日志级别，一般不会使用。 DEBUG 指出细粒度信息事件对调试应用程序是非常有帮助的，主要用于开发过程中打印一些运行信息。 INFO 消息在粗粒度级别上突出强调应用程序的运行过程。打印一些你感兴趣的或者重要的信息，这个可以用于生产环境中输出程序运行的一些重要信息，但是不能滥用，避免打印过多的日志。 WARN 表明会出现潜在错误的情形，有些信息不是错误信息，但是也要给程序员的一些提示。 ERROR 指出虽然发生错误事件，但仍然不影响系统的继续运行。打印错误和异常信息，如果不想输出太多的日志，可以使用这个级别。 FATAL 指出每个严重的错误事件将会导致应用程序的退出。这个级别比较高了。重大错误，这种级别你可以直接停止程序了。 OFF 最高等级的，用于关闭所有日志记录。 如果将log level设置在某一个级别上，那么比此级别优先级高的log都能打印出来。例如，如果设置优先级为WARN，那么OFF、FATAL、ERROR、WARN 4个级别的log能正常输出，而INFO、DEBUG、TRACE、 ALL级别的log则会被忽略。Log4j建议只使用四个级别，优先级从高到低分别是ERROR、WARN、INFO、DEBUG。 从我们实验的结果可以看出，log4j默认的优先级为ERROR或者WARN（实际上是ERROR）。 使用 例如使用ERROR级别，就不会生成WARN INFO等详细异常。","categories":[],"tags":[],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2019-02-14T16:37:47.004Z","updated":"2019-02-14T16:37:47.006Z","comments":true,"path":"2019/02/15/hello-world/","link":"","permalink":"http://yoursite.com/2019/02/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}
{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"","slug":"Day16_Cookie","date":"2019-07-18T01:07:39.512Z","updated":"2018-12-13T12:19:14.000Z","comments":true,"path":"2019/07/18/Day16_Cookie/","link":"","permalink":"http://yoursite.com/2019/07/18/Day16_Cookie/","excerpt":"","text":"购物车解决方案登录前存在cookie中，登录后存到redis中 购物车数据结构12按商家进行分组 集合单个商家里又是集合 工程搭建1234567891011创建接口 依赖pojo创建服务实现 war 参考userservice导依赖 mq不需要可删除 添加web.xml spring配置文件 jms不需要 改dubbo配置创建web工程 加依赖 需要单点登录 ss相关依赖 改端口 设置cart.html不拦截 拷贝UserDetail类 拷贝页面资源cart跟几个前端目录添加操作cookie工具类 common中 添加servlet-api依赖 CookieUtil 123pojo.group中创建Cart实体类 商家id 商家名称 计算总金额 购物车店铺集合 购物车明细集合 12尽可能把js中罗技封装到服务层，不一定是跟后端打交道才放service.toFixed(2) 取两位精度 移动到服务层 配置防止获取用户名报错，普通配置不拦截do会使获取用户名报错 先拦截do再拦截角色 cookieUtil123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228package util;import java.io.UnsupportedEncodingException;import java.net.URLDecoder;import java.net.URLEncoder;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * * Cookie 工具类 * */public final class CookieUtil &#123; /** * 得到Cookie的值, 不编码 * * @param request * @param cookieName * @return */ public static String getCookieValue(HttpServletRequest request, String cookieName) &#123; return getCookieValue(request, cookieName, false); &#125; /** * 得到Cookie的值, * * @param request * @param cookieName * @return */ public static String getCookieValue(HttpServletRequest request, String cookieName, boolean isDecoder) &#123; Cookie[] cookieList = request.getCookies(); if (cookieList == null || cookieName == null) &#123; return null; &#125; String retValue = null; try &#123; for (int i = 0; i &lt; cookieList.length; i++) &#123; if (cookieList[i].getName().equals(cookieName)) &#123; if (isDecoder) &#123; retValue = URLDecoder.decode(cookieList[i].getValue(), \"UTF-8\"); &#125; else &#123; retValue = cookieList[i].getValue(); &#125; break; &#125; &#125; &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return retValue; &#125; /** * 得到Cookie的值, * * @param request * @param cookieName * @return */ public static String getCookieValue(HttpServletRequest request, String cookieName, String encodeString) &#123; Cookie[] cookieList = request.getCookies(); if (cookieList == null || cookieName == null) &#123; return null; &#125; String retValue = null; try &#123; for (int i = 0; i &lt; cookieList.length; i++) &#123; if (cookieList[i].getName().equals(cookieName)) &#123; retValue = URLDecoder.decode(cookieList[i].getValue(), encodeString); break; &#125; &#125; &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return retValue; &#125; /** * 设置Cookie的值 不设置生效时间默认浏览器关闭即失效,也不编码 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue) &#123; setCookie(request, response, cookieName, cookieValue, -1); &#125; /** * 设置Cookie的值 在指定时间内生效,但不编码 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage) &#123; setCookie(request, response, cookieName, cookieValue, cookieMaxage, false); &#125; /** * 设置Cookie的值 不设置生效时间,但编码 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, boolean isEncode) &#123; setCookie(request, response, cookieName, cookieValue, -1, isEncode); &#125; /** * 设置Cookie的值 在指定时间内生效, 编码参数 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, boolean isEncode) &#123; doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, isEncode); &#125; /** * 设置Cookie的值 在指定时间内生效, 编码参数(指定编码) */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, String encodeString) &#123; doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, encodeString); &#125; /** * 删除Cookie带cookie域名 */ public static void deleteCookie(HttpServletRequest request, HttpServletResponse response, String cookieName) &#123; doSetCookie(request, response, cookieName, \"\", -1, false); &#125; /** * 设置Cookie的值，并使其在指定时间内生效 * * @param cookieMaxage cookie生效的最大秒数 */ private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, boolean isEncode) &#123; try &#123; if (cookieValue == null) &#123; cookieValue = \"\"; &#125; else if (isEncode) &#123; cookieValue = URLEncoder.encode(cookieValue, \"utf-8\"); &#125; Cookie cookie = new Cookie(cookieName, cookieValue); if (cookieMaxage &gt; 0) cookie.setMaxAge(cookieMaxage); if (null != request) &#123;// 设置域名的cookie String domainName = getDomainName(request); System.out.println(domainName); if (!\"localhost\".equals(domainName)) &#123; cookie.setDomain(domainName); &#125; &#125; cookie.setPath(\"/\"); response.addCookie(cookie); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 设置Cookie的值，并使其在指定时间内生效 * * @param cookieMaxage cookie生效的最大秒数 */ private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, String encodeString) &#123; try &#123; if (cookieValue == null) &#123; cookieValue = \"\"; &#125; else &#123; cookieValue = URLEncoder.encode(cookieValue, encodeString); &#125; Cookie cookie = new Cookie(cookieName, cookieValue); if (cookieMaxage &gt; 0) cookie.setMaxAge(cookieMaxage); if (null != request) &#123;// 设置域名的cookie String domainName = getDomainName(request); System.out.println(domainName); if (!\"localhost\".equals(domainName)) &#123; cookie.setDomain(domainName); &#125; &#125; cookie.setPath(\"/\"); response.addCookie(cookie); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 得到cookie的域名 */ private static final String getDomainName(HttpServletRequest request) &#123; String domainName = null; String serverName = request.getRequestURL().toString(); if (serverName == null || serverName.equals(\"\")) &#123; domainName = \"\"; &#125; else &#123; serverName = serverName.toLowerCase(); serverName = serverName.substring(7); final int end = serverName.indexOf(\"/\"); serverName = serverName.substring(0, end); final String[] domains = serverName.split(\"\\\\.\"); int len = domains.length; if (len &gt; 3) &#123; // www.xxx.com.cn domainName = \".\" + domains[len - 3] + \".\" + domains[len - 2] + \".\" + domains[len - 1]; &#125; else if (len &lt;= 3 &amp;&amp; len &gt; 1) &#123; // xxx.com or xxx.cn domainName = \".\" + domains[len - 2] + \".\" + domains[len - 1]; &#125; else &#123; domainName = serverName; &#125; &#125; if (domainName != null &amp;&amp; domainName.indexOf(\":\") &gt; 0) &#123; String[] ary = domainName.split(\"\\\\:\"); domainName = ary[0]; &#125; return domainName; &#125;&#125; 需要依赖servlet 12345&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"Day15_CAS","date":"2019-07-18T01:07:39.483Z","updated":"2018-12-13T12:19:14.000Z","comments":true,"path":"2019/07/18/Day15_CAS/","link":"","permalink":"http://yoursite.com/2019/07/18/Day15_CAS/","excerpt":"","text":"单点登录（Single Sign On） CAS默认账号密码 12345&lt;property name=&quot;users&quot;&gt; &lt;map&gt; &lt;entry key=&quot;casuser&quot; value=&quot;Mellon&quot;/&gt; &lt;/map&gt; &lt;/property&gt; 配置web.xml 123456789filter配置casServerLoginUrl配置cas服务端还需要serverName配置本机IP传给服务端filter-mapping配置过滤路径&lt;!-- 该过滤器负责实现 HttpServletRequest 请求的包裹， 比如允许开发者通过HttpServletRequest 的 getRemoteUser()方法获得 SSO 登录用户的登录名，可选配置。 --&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; 配置cas发布配置 12345原先固定用户无需删除，加入数据源配置加密器dbAuthHandle根据用户名把密码列出，其中配密码加密器更换源务必添加所需jar包 将下列标注位置源改成新加的源 WEB-INF/view/hsp/default/ui里更换登录登出页面 显示错误信息的，放在页面的合适位置即可 错误提示是英文。I18N国际化。cas-servlet中改成中文语言包 SpringSecurity结合CAS 主要是获取用户角色权限作用，与cas联系到一起 单点登出 真正的单点登录是第一个beans，第二个beans是配置关联关系的。 集群CAS搭建CAS集群，将ticket什么都缓存到redis中","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"Day14_SMS","date":"2019-07-18T01:07:39.470Z","updated":"2018-12-13T12:19:14.000Z","comments":true,"path":"2019/07/18/Day14_SMS/","link":"","permalink":"http://yoursite.com/2019/07/18/Day14_SMS/","excerpt":"","text":"SpringBoot 框架与短信解决方案以消息形式存在MQ，以子系统（微服务）实时监控ActiveMQ，有要发短信的就是实时通过运营商发出去。 Spring Boot提供更快开发体验；开箱即用，没有代码生成，不需要xml代码配置；提供常用非功能性特征；更快速使用spring。市场上很多用来开发微服务。 Spring Boot 入门小 Demo创建 Maven 工程 springboot_demo（打包方式 jar），这里不需要在toncat中运行，是微服务，tomcat打在依赖jar中。含44种starter，原理依赖传递。在 pom.xml 中添加如下依赖 1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&lt;version&gt;1.4.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 而这些 jar 包正式我们做开发时需要导入的 jar 包。因为这些 jar 包被我们刚才引入的spring-boot-starter-web 所引用了，所以我们引用 spring-boot-starter-web 后会自动把依赖传递过来。 热部署，部署完不需要重启服务 变更 JDK 版本我们发现默认情况下工程的 JDK 版本是 1.6 ,而我们通常用使用 1.7 的版本，所以我们需要在pom.xml 中添加以下配置 123&lt;properties&gt; &lt;java.version&gt;1.7&lt;/java.version&gt; &lt;/properties&gt; 引导类12345678910111213package cn.itcast.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication//需要注解申明是启动类public class Application&#123; public static void main(String[] args) &#123; //源 ， 参数 SpringApplication.run(Application.class, args); //Application.class自身类 传递过来args参数 //可以在这添加beans &#125;&#125; 启动类直接运行即可 简单解释一下，@SpringBootApplication 其实就是以下三个注解的总和@Configuration： 用于定义一个配置类@EnableAutoConfiguration ：Spring Boot 会自动根据你 jar 包的依赖来自动配置项目。@ComponentScan： 告诉 Spring 哪个 packages 的用注解标识的类 会被 spring 自动扫描并且装入 bean 容器。 Spring MVC 实现 Hello World 输出新建demo类，默认8080端口 在浏览器地址栏输入 http://localhost:8080/info 即可看到运行结果 123456789@RestControllerpublic class HelloWorldController&#123; @RequestMapping(\"/info\") public String info() &#123; return \"HelloWorld\"; &#125;&#125; 设置端口（配置文件在资源目录）在 src/main/resources 下创建 application.properties 1server.port=8088 env属性文件读取在 src/main/resources 下的 application.properties 增加配置，读取如下：url=http://www.itcast.cn 1234567@Autowiredprivate Environment env;@RequestMapping(\"/info\")public String info()&#123; return \"HelloWorld~~\" + env.getProperty(\"url\");&#125; 更改配置文件、增加方法或类不能实时生效，添加热部署即可： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; 加完依赖后重启下，重启后更改就不需要重启了。 Spring Boot 与 ActiveMQ 整合使用内嵌服务在 pom.xml 中引入 ActiveMQ 起步依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;&lt;/dependency&gt; 创建消息生产者（这里采用的是内置的MQ,不会在我们设置的mq里看到） 123456789101112@RestControllerpublic class QueueController&#123; @Autowired private JmsMessagingTemplate jmsMessagingTemplate; @RequestMapping(\"/send\") public void send(String text) &#123; //convertAndSend转换并发送 ：目标，文本 jmsMessagingTemplate.convertAndSend(\"itcast\", text); &#125;&#125; 创建消息消费者 123456789@Componentpublic class Consumer&#123; @JmsListener(destination = \"itcast\") public void readMessage(String text) &#123; System.out.println(\"接收到消息：\" + text); &#125;&#125; 测试：启动服务后，在浏览器执行http://localhost:8088/send.do?text=aaaaa 内嵌的方便测试不推荐使用。配置使用外部服务，在 src/main/resources 下的 application.properties 增加配置, 指定 ActiveMQ 的地址： 1spring.activemq.broker-url=tcp://192.168.25.135:61616 运行后，会在 activeMQ 中看到发送的 queue 发送 Map 信息修改 QueueController.java 1234567@RequestMapping(\"/sendmap\")public void sendMap()&#123; Map map=new HashMap&lt;&gt;(); map.put(\"mobile\", \"13900001111\"); map.put(\"content\", \"恭喜获得 10 元代金券\"); jmsMessagingTemplate.convertAndSend(\"itcast_map\",map);&#125; 修改 Consumer.java 1234@JmsListener(destination=\"itcast_map\")public void readMap(Map map)&#123; System.out.println(map);&#125; 短信微服务一个项目做一个微服务就行，跟品优购也没关系，通过异步调用短信微服务再传给阿里大于。 工程搭建创建工程 itcast_sms （JAR 工程），POM 文件引入依赖 123456789101112131415161718192021222324252627282930&lt;properties&gt; &lt;java.version&gt;1.7&lt;/java.version&gt; &lt;/properties&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&lt;version&gt;1.4.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-dysmsapi&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;3.2.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 不使用阿里大于的不用导大于的包，应导对应的，创建引导： 1234567891011package cn.itcast.sms;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application&#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 创建配置文件 application.properties 1234server.port=9003spring.activemq.broker-url=tcp://192.168.25.88:61616accessKeyId=不告诉你accessKeySecret=不告诉你 换jar依赖 删除阿里大于util（如果有） 品优购工程搭建用户服务接口层（1）创建 pinyougou-user-interface（jar）（2）引入 pojo 依赖 用户服务实现层（1）创建 pinyougou-user-service（war）（2）引入 spring dubbox activeMQ 相关依赖，引入依赖（ pinyougou-user-interfacepinyougou-dao pinyougou-common），运行端口为 9006（3）添加 web.xml（4）创建 Spring 配置文件 applicationContext-service.xml 和 applicationContent-tx.xml 1234&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20886&quot; /&gt; &lt;dubbo:annotation package=&quot;com.pinyougou.user.service.impl&quot; /&gt; &lt;dubbo:application name=&quot;pinyougou-user-service&quot;/&gt; &lt;dubbo:registry address=&quot;zookeeper://192.168.25.135:2181&quot;/ 用户中心 WEB 层创建 war 工程 pinyougou-user-web 我们将注册功能放入此工程（1）添加 web.xml（2）引入依赖 pinyougou-user-interface 、spring 相关依赖（参照其它 web 工程）,tomcat 运行端口 9106（3）添加 spring 配置文件（4）拷贝静态原型页面 register.html 及相关资源 前台比较两次密码输入是否一致 手机格式校验类 提示log4j没找到，加jar包","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"Day13_JMS","date":"2019-07-18T01:07:39.435Z","updated":"2018-12-13T12:19:14.000Z","comments":true,"path":"2019/07/18/Day13_JMS/","link":"","permalink":"http://yoursite.com/2019/07/18/Day13_JMS/","excerpt":"","text":"JMS入门消息中间件JMS是规范 ActiveMQ是实现 执行时间过长不需要返回结果的使用消息中间件，例如搜索跟页面生成 常见中间件：ActiveMQ，Kafka均为Apache 的项目，卡夫卡具有高吞吐，完全分布式系统，适合处理海量数据 JMS消息传递方式点对点：生产者发布消息只被一个消费者接收（Queue队列） 发布/订阅：一个生产者产生消息被多个消费者同事接收 ActiveMQ页面简单界面使用 假设服务器地址为 192.168.25.135 ，打开浏览器输入地址http://192.168.25.135:8161/ 即可进入 ActiveMQ 管理页面 一对一生产者： 123456789101112131415161718192021//1.创建连接工厂ConnectionFactory connectionFactory = newActiveMQConnectionFactory(\"tcp://192.168.25.135:61616\");//2.获取连接Connection connection = connectionFactory.createConnection();//3.启动连接connection.start();//4.获取 session (参数 1：是否启动事务,参数 2：消息确认模式)Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);//5.创建队列对象Queue queue = session.createQueue(\"test-queue\");//6.创建消息生产者MessageProducer producer = session.createProducer(queue);//7.创建消息TextMessage textMessage = session.createTextMessage(\"欢迎来到神奇的品优购世界\");//8.发送消息producer.send(textMessage);//9.关闭资源producer.close();session.close();connection.close(); 搜索只需要执行一次，适合点对点方式；消费者不在线上线后可接收，多个消费者接收同一个生产者信息，速度快的会接收。消费者： 12345678910111213141516171819202122232425262728293031323334//1.创建连接工厂ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://192.168.25.135:61616\");//2.创建连接Connection connection = connectionFactory.createConnection();//3.启动连接connection.start();//4.获取session(会话对象) 参数1：是否启动事务 参数2：消息确认方式Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);//5.创建队列对象Queue queue = session.createQueue(\"test-queue\");//6.创建消息消费者对象MessageConsumer consumer = session.createConsumer(queue);//7.设置监听consumer.setMessageListener(new MessageListener()&#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage)message; try &#123; System.out.println(\"提取的消息：\" + textMessage.getText() ); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125;);//8.等待键盘输入 控制台程序需要加 网页程序不需要System.in.read();//9.关闭资源consumer.close();session.close();connection.close(); 一对多（发布/订阅模式）生产者： 1234567891011121314151617181920//1.创建连接工厂ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://192.168.25.135:61616\");//2.创建连接Connection connection = connectionFactory.createConnection();//3.启动连接connection.start();//4.获取session(会话对象) 参数1：是否启动事务 参数2：消息确认方式Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);//5.创建主题对象Topic topic = session.createTopic(\"test-topic\");//6.创建消息生产者对象MessageProducer producer = session.createProducer(topic);//7.创建消息对象（文本消息）TextMessage textMessage = session.createTextMessage(\"欢迎来到申请的品优购世界\");//8.发送消息producer.send(textMessage);//9.关闭资源producer.close();session.close();connection.close(); 消费者： 12345678910111213141516171819202122232425262728293031323334353637//1.创建连接工厂ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://192.168.25.135:61616\");//2.创建连接Connection connection = connectionFactory.createConnection();//3.启动连接connection.start();//4.获取session(会话对象) 参数1：是否启动事务 参数2：消息确认方式Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);//5.创建主题对象Topic topic = session.createTopic(\"test-topic\");//6.创建消息消费者对象MessageConsumer consumer = session.createConsumer(topic);//7.设置监听consumer.setMessageListener(new MessageListener()&#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage)message; try &#123; System.out.println(\"提取的消息：\" + textMessage.getText() ); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125;);//8.等待键盘输入 防止关闭System.in.read();//9.关闭资源consumer.close();session.close();connection.close(); 生产者发送消息后 如果消费者不在线则消费不到信息，发送消息是实时的，在线消费者可接收 当执行任务在每个节点都用到时候使用一对多。如多个服务器都要部署详情页，则需要一对多生成静态页面。 SpringJMSSpring对JMS的封装支持，这里生产者跟消费者工程分离 applicationContext-jms-producer.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:amq=\"http://activemq.apache.org/schema/core\" xmlns:jms=\"http://www.springframework.org/schema/jms\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"cn.itcast.demo\"&gt;&lt;/context:component-scan&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id=\"targetConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;property name=\"brokerURL\" value=\"tcp://192.168.25.129:61616\"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.SingleConnectionFactory\"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name=\"targetConnectionFactory\" ref=\"targetConnectionFactory\"/&gt; &lt;/bean&gt; &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt; &lt;bean id=\"jmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\"&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 文本信息--&gt; &lt;bean id=\"queueTextDestination\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt; &lt;constructor-arg value=\"queue_text\"/&gt; &lt;/bean&gt; &lt;!--这个是订阅模式 文本信息--&gt; &lt;bean id=\"topicTextDestination\" class=\"org.apache.activemq.command.ActiveMQTopic\"&gt; &lt;constructor-arg value=\"topic_text\"/&gt; &lt;/bean&gt; &lt;/beans&gt; Producer.class1234567891011121314151617181920212223@Componentpublic class QueueProducer&#123; @Autowired private JmsTemplate jmsTemplate; @Autowired private Destination queueTextDestination; /** * 发送文本消息 * @param text */ public void sendTextMessage(final String text) //内部类中为确保text信息一致，要加final 不然会报错 &#123; jmsTemplate.send(queueTextDestination, new MessageCreator() &#123; public Message createMessage(Session session) throws JMSException &#123; return session.createTextMessage(text); &#125; &#125;); &#125;&#125; 单元测试类 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:applicationContext-jms-producer.xml\")public class TestQueue&#123; @Autowired private QueueProducer queueProducer; @Test public void testSend() &#123; queueProducer.sendTextMessage(\"SpringJms-点对点\"); &#125;&#125; 品优购里使用解耦，删除maneger-web(这里是消息提供者)中的依赖，删除相关关联代码。添加jms配置文件。引入jms（GoodsController中）： 1234@Autowiredprivate Destination queueSolrDestination;//用于发送 solr 导入的消息@Autowiredprivate JmsTemplate jmsTemplate; 123456789101112//调用搜索接口实现数据批量导入if(itemList.size() &gt; 0)&#123; final String jsonString = JSON.toJSONString(itemList); jmsTemplate.send(queueSolrDestination, new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; return session.createTextMessage(jsonString); &#125; &#125;);","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"Day12_freeMarker","date":"2019-07-18T01:07:39.422Z","updated":"2018-12-13T12:19:14.000Z","comments":true,"path":"2019/07/18/Day12_freeMarker/","link":"","permalink":"http://yoursite.com/2019/07/18/Day12_freeMarker/","excerpt":"","text":"网页静态化Freemarker使用FreeMarker 是一个用 Java 语言编写的模板引擎，它基于模板来生成文本输出。FreeMarker 与 Web 容器无关，即在 Web 运行时，它并不知道 Servlet 或 HTTP。它不仅可以用作表现层的实现技术，而且还可以用于生成 XML，JSP 或 Java 等 Freemarker 入门小 DEMO工程引入依赖12345&lt;dependency&gt;&lt;groupId&gt;org.freemarker&lt;/groupId&gt;&lt;artifactId&gt;freemarker&lt;/artifactId&gt;&lt;version&gt;2.3.23&lt;/version&gt;&lt;/dependency&gt; 创建模板文件模板文件放哪里都可以，只要路径正确即可 模板文件中四种元素1、文本，直接输出的部分2、注释，即&lt;#–…–&gt;格式不会输出 跟html原生注释不一样，这个注释不会显示到HTML页面中，只会在模板中出现3、插值（Interpolation）：即${..}部分,将使用数据模型中的部分替代输出 不可或缺定义不全会报错 4、FTL 指令：FreeMarker 指令，和 HTML 标记类似，名字前加#予以区分，不会输出。我们现在就创建一个简单的创建模板文件 test.ftl 12345678910&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;Freemarker 入门小 DEMO &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;#--我只是一个注释，我不会有任何输出这里有文本、插值和注释--&gt;$&#123;name&#125;,你好。$&#123;message&#125;&lt;/body&gt;&lt;/html&gt; 生成文件第一步：创建一个 Configuration 对象，直接 new 一个对象。构造方法的参数就是freemarker 的版本号。freemarker.template第二步：设置模板文件所在的路径。第三步：设置模板文件使用的字符集。一般就是 utf-8.第四步：加载一个模板，创建一个模板对象。第五步：创建一个模板使用的数据集，可以是 pojo 也可以是 map。一般是 Map。第六步：创建一个 Writer 对象，一般创建一 FileWriter 对象，指定生成的文件名。第七步：调用模板对象的 process 方法输出文件。第八步：关闭流 创建 Test 类 main 方法如下： 12345678910111213141516171819//1.创建配置类Configuration configuration = new Configuration(Configuration.getVersion());//2.设置模板所在的目录configuration.setDirectoryForTemplateLoading(new File(\"D:/pinyougou_work/freemarkerDemo/src/main/resources/\"));//3.设置字符集configuration.setDefaultEncoding(\"utf-8\");//4.加载模板Template template = configuration.getTemplate(\"test.ftl\");//5.创建数据模型Map map = new HashMap();map.put(\"name\", \"张三 \");map.put(\"message\", \"欢迎来到神奇的品优购世界！\");//6.创建 Writer 对象Writer out = new FileWriter(new File(\"d:\\\\test.html\"));//7.输出template.process(map, out);//8.关闭 Writer 对象out.close(); 执行后，在 D 盘根目录即可看到生成的 test.html ，打开看看 FTL 指令assign 指令此指令用于在页面上定义一个变量（1）定义简单类型（assign指派的意思）： 12&lt;#assign linkman=&quot;周先生&quot;&gt;联系人：$&#123;linkman&#125; （2）定义对象类型： 12&lt;#assign info=&#123;&quot;mobile&quot;:&quot;13301231212&quot;,&apos;address&apos;:&apos;北京市昌平区王府街&apos;&#125; &gt;电话：$&#123;info.mobile&#125; 地址：$&#123;info.address&#125; include 指令此指令用于模板文件的嵌套，可以复用 创建模板文件 head.ftl 1&lt;h1&gt;黑马信息网&lt;/h1&gt; 我们修改 test.ftl，在模板文件中使用 include 指令引入刚才我们建立的模板 1&lt;#include &quot;head.ftl&quot;&gt; if 指令在模板文件上添加 12345&lt;#if success=true&gt; 你已通过实名认证&lt;#else&gt; 你未通过实名认证&lt;/#if&gt; 在 freemarker 的判断中，可以使用= 也可以使用== 在代码中对 str 变量赋值 1map.put(&quot;success&quot;, true); list 指令（1）代码中对变量 goodsList 赋值 1234567891011121314List goodsList=new ArrayList();Map goods1=new HashMap();goods1.put(&quot;name&quot;, &quot;苹果&quot;);goods1.put(&quot;price&quot;, 5.8);Map goods2=new HashMap();goods2.put(&quot;name&quot;, &quot;香蕉&quot;);goods2.put(&quot;price&quot;, 2.5);Map goods3=new HashMap();goods3.put(&quot;name&quot;, &quot;橘子&quot;);goods3.put(&quot;price&quot;, 3.2);goodsList.add(goods1);goodsList.add(goods2);goodsList.add(goods3);map.put(&quot;goodsList&quot;, goodsList); （2）在模板文件上添加 1234----商品价格表----&lt;#list goodsList as goods&gt; $&#123;goods_index+1&#125; 商品名称： $&#123;goods.name&#125; 价格：$&#123;goods.price&#125;&lt;br&gt;&lt;/#list&gt; ${goods_index}固定写法取下标，从0开始，上述代码为了从1开始加1的 拓展：JSP引入静态引入： 动态引入： 静态直接拼在一起进行编译，动态直接使用其他页面结果 内建函数内建函数语法格式： 变量+?+函数名称 获取集合大小我们使用 size 函数来实现，代码如下：共 ${goodsList?size} 条记录 转换 JSON 字符串为对象我们通常需要将 json 字符串转换为对象，利用text?eval 123&lt;#assign text=&quot;&#123;&apos;bank&apos;:&apos;工商银行&apos;,&apos;account&apos;:&apos;10101920201920212&apos;&#125;&quot; /&gt;&lt;#assign data=text?eval /&gt;开户行：$&#123;data.bank&#125; 账号：$&#123;data.account&#125; 日期格式化代码中对变量赋值：dataModel.put(&quot;today&quot;, new Date()); 在模板文件中加入 1234当前日期：$&#123;today?date&#125; &lt;br&gt;当前时间：$&#123;today?time&#125; &lt;br&gt; 当前日期+时间：$&#123;today?datetime&#125; &lt;br&gt; 日期格式化： $&#123;today?string(&quot;yyyy 年 MM 月&quot;)&#125; 运行效果如下： 数字转换为字符串代码中对变量赋值：map.put(&quot;point&quot;, 102920122);修改模板：累计积分：${point}页面显示：累计积分：102,920,122 我们会发现数字会以每三位一个分隔符显示，有些时候我们不需要这个分隔符，就需要将数字转换为字符串,使用内建函数 c累计积分：${point?c} 空值处理运算符如果你在模板中使用了变量但是在代码中没有对变量赋值，那么运行生成时会抛出异常。但是有些时候，有的变量确实是 null，怎么解决这个问题呢？ 判断某变量是否存在: “??”用法为:variable??,如果该变量存在,返回 true,否则返回 false 12345&lt;#if aaa??&gt; aaa 变量存在&lt;#else&gt; aaa 变量不存在&lt;/#if&gt; 缺失变量默认值: “!”我们除了可以判断是否为空值，也可以使用!对 null 值做转换处理在模板文件中加入${aaa!&#39;-&#39;} 在代码中不对 aaa 赋值，也不会报错了 ，当 aaa 为 null 则返回！后边的内容- 运算符算数运算符FreeMarker 表达式中完全支持算术运算,FreeMarker 支持的算术运算符包括:+, - , * , / , % 逻辑运算符逻辑运算符有如下几个:逻辑与:&amp;&amp;逻辑或:||逻辑非:!逻辑运算符只能作用于布尔值,否则将产生错误 比较运算符表达式中支持的比较运算符有如下几个:1 =或者==:判断两个值是否相等.2 !=:判断两个值是否不等.3 &gt;或者 gt:判断左边值是否大于右边值4 &gt;=或者 gte:判断左边值是否大于等于右边值5 &lt;或者 lt:判断左边值是否小于右边值6 &lt;=或者 lte:判断左边值是否小于等于右边值注意: =和!=可以用于字符串,数值和日期来比较是否相等,但=和!=两边必须是相同类型的值,否则会产生错误,而且 FreeMarker 是精确比较,”x”,”x “,”X”是不等的.其它的运行符可以作用于数字和日期,但不能作用于字符串,大部分的时候,使用gt等字母运算符代替&gt;会有更好的效果,因为 FreeMarker 会把&gt;解释成 FTL 标签的结束字符,当然,也可以使用括号来避免这种情况,如:&lt;#if (x&gt;y)&gt; 大于号问题：大于号与标签冲突，要不用标签，要不用括号扩起来 商品详情页-数据显示运用 Freemarker 技术来实现商品详细页的静态化。通过地址栏输入某地址，如下形式http://localhost:9101/gen_item.do?goodsId=149187842867952能在本地电脑某目录生成商品详细页，页面的名称为商品 id.html 工程搭建服务接口层创建 pinyougou-page-interface 工程，创建 com.pinyougou.page.service 包,包下创建接口 1234567891011121314/*** 商品详细页接口* @author Administrator**/public interface ItemPageService&#123; /** * 生成商品详细页 * @param goodsId */ public boolean genItemHtml(Long goodsId); //返回布尔是想知道是成功还是失败&#125; 服务实现层（1）创建 war 工程 pinyougou-page-service（2）pom.xml 引入依赖 参见其它服务工程, 另外添加 freemarker 依赖 注意改端口 1234&lt;dependency&gt;&lt;groupId&gt;org.freemarker&lt;/groupId&gt;&lt;artifactId&gt;freemarker&lt;/artifactId&gt;&lt;/dependency&gt; （3）添加 web.xml 参见其它服务工程（4）spring 配置文件 参见其它服务工程 ，例如从content-service中复制，注意改扫描包名跟端口号。另外配置： 1234&lt;bean id=\"freemarkerConfig\" class=\"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer\"&gt; &lt;property name=\"templateLoaderPath\" value=\"/WEB-INF/ftl/\" /&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\" /&gt;&lt;/bean&gt; （5）创建属性文件 内容为： 1pagedir=d:\\\\item\\\\ 用于配置网页生成目录 （6）建立 com.pinyougou.page.service.impl 包，包下建立类，下列代码先先好流程再写数据 12345678910111213141516171819202122232425262728293031323334353637@Servicepublic class ItemPageServiceImpl implements ItemPageService&#123; @Value(\"$&#123;pagedir&#125;\") private String pagedir;//6 @Autowired private FreeMarkerConfig freeMarkerConfig;//1 @Autowired private TbGoodsMapper goodsMapper;//9 @Autowired private TbGoodsDescMapper goodsDescMapper;//10 @Override public boolean genItemHtml(Long goodsId) &#123; try &#123; Configuration configuration = freeMarkerConfig.getConfiguration(); //2 Template template = configuration.getTemplate(\"item.ftl\");//3 Map dataModel = new HashMap&lt;&gt;();//4 //1.加载商品表数据 TbGoods goods = goodsMapper.selectByPrimaryKey(goodsId);//11 dataModel.put(\"goods\", goods);//12 //2.加载商品扩展表数据 TbGoodsDesc goodsDesc = goodsDescMapper.selectByPrimaryKey(goodsId);//13 dataModel.put(\"goodsDesc\", goodsDesc);//14 Writer out = new FileWriter(pagedir + goodsId + \".html\");//5 template.process(dataModel, out);//7 out.close();//8 return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125;&#125; （7）将 item.html 拷贝至 web-inf/ftl 下 ，修改扩展名为 ftl ,将商品名称用插值代替 123&lt;div class=\"sku-name\"&gt; &lt;h4&gt;$&#123;goods.goodsName&#125;&lt;/h4&gt;&lt;/div&gt; （8）在 D 盘建立文件夹 item,将必要的样式表和 Js 拷贝到此目录下，此目录为生成的目录 运营商管理后台（1）pinyougou-manager-web 引入依赖 pinyougou-page-interface（2）在 GoodsController.java 中新增方法 12345678910@Reference(timeout=40000)private ItemPageService itemPageService;/*** 生成静态页（测试）* @param goodsId*/@RequestMapping(\"/genHtml\")public void genHtml(Long goodsId)&#123; itemPageService.genItemHtml(goodsId);&#125; 商品详情页模板构建模板模块化引入此时我们的 item.ftl 内容较多，当我们编辑时不容易快速找到编辑的位置，所以我们将头部分拆分到 head.ftl ,将尾部拆分到 foot.ftl ,用 include 指令在 item.ftl 中引入 。 拆分头尾 通过 &lt;#include “”&gt;引入 生成基本数据在模板中找到合适的位置，用插值替换静态文本 123456789副标题&lt;div class=&quot;news&quot;&gt;&lt;span&gt;$&#123;goods.caption&#125;&lt;/span&gt;&lt;/div&gt;商品价格&lt;div class=&quot;fl price&quot;&gt;&lt;i&gt;yen&lt;/i&gt;&lt;em&gt;$&#123;goods.price&#125;&lt;/em&gt;&lt;span&gt;降价通知&lt;/span&gt;&lt;/div&gt;商品详细&lt;div class=&quot;intro-detail&quot;&gt;&lt;!-- 商品详情 --&gt; $&#123;goodsDesc.introduction&#125;&lt;/div&gt;包装售后与服务&lt;div id=&quot;two&quot; class=&quot;tab-pane&quot;&gt;&lt;p&gt;$&#123;goodsDesc.packageList&#125;&lt;/p&gt;&lt;/div&gt;&lt;div id=&quot;three&quot; class=&quot;tab-pane&quot;&gt;&lt;p&gt;$&#123;goodsDesc.saleService&#125;&lt;/p&gt;&lt;/div&gt; 运行控制层代码，测试生成效果http://localhost:9101/goods/genHtml.do?g 生成图片列表编辑模板文件 12&lt;#--图片列表 --&gt;&lt;#assign imageList=goodsDesc.itemImages?eval /&gt; 这一句要转换图片列表的 json 字符串图片部分的代码 为防止放大镜图片暂满整个屏幕，因此限制图片大小 1234567891011121314151617181920&lt;!--默认第一个预览--&gt;&lt;div id=\"preview\" class=\"spec-preview\"&gt;&lt;span class=\"jqzoom\"&gt;&lt;#if (imageList?size&gt;0)&gt;&lt;img jqimg=\"$&#123;imageList[0].url&#125;\" src=\"$&#123;imageList[0].url&#125;\" width=\"400px\" height=\"400px\" /&gt;&lt;/#if&gt;&lt;/span&gt;&lt;/div&gt;&lt;!--下方的缩略图--&gt;&lt;div class=\"spec-scroll\"&gt;&lt;div class=\"items\"&gt;&lt;ul&gt;&lt;#list imageList as item&gt;&lt;li&gt;&lt;img src=\"$&#123;item.url&#125;\" bimg=\"$&#123;item.url&#125;\" onmousemove=\"preview(this)\" /&gt;&lt;/li&gt;&lt;/#list&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt; 生成效果如下： 生成扩展属性列表修改模板 首先进行 json 转换 12&lt;#--扩展属性列表 --&gt;&lt;#assign customAttributeList=goodsDesc.customAttributeItems?eval /&gt; 显示扩展属性数据，如果扩展属性为空则不显示此条数据 &lt;#if item.value??&gt;判断变量是否存在，存在就显示 12345&lt;#list customAttributeList as item&gt;&lt;#if item.value??&gt;&lt;li&gt;$&#123;item.text&#125; ：$&#123;item.value&#125;&lt;/li&gt;&lt;/#if&gt;&lt;/#list&gt; 生成规格列表修改模板 转换规格列表 12&lt;#--规格列表 --&gt;&lt;#assign specificationList=goodsDesc.specificationItems?eval /&gt; 此时，我们需要使用嵌套循环 123456789101112&lt;#list specificationList as specification&gt;&lt;dl&gt;&lt;dt&gt;&lt;div class=\"fl title\"&gt;&lt;i&gt;$&#123;specification.attributeName&#125;&lt;/i&gt;&lt;/div&gt;&lt;/dt&gt;&lt;#list specification.attributeValue as item&gt;&lt;dd&gt;&lt;a href=\"javascript:;\" &gt;$&#123;item&#125;&lt;/a&gt;&lt;/dd&gt;&lt;/#list&gt;&lt;/dl&gt;&lt;/#list&gt; 生成商品类型面包屑修改 ItemPageServiceImpl ，读取三级商品分类名称，加入到数据模型中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Servicepublic class ItemPageServiceImpl implements ItemPageService&#123; @Autowired private FreeMarkerConfig freeMarkerConfig; @Autowired private TbGoodsMapper goodsMapper; @Autowired private TbGoodsDescMapper goodsDescMapper; @Autowired private TbItemCatMapper itemCatMapper; @Override public boolean genItemHtml(Long goodsId) &#123; try &#123; Configuration configuration = freeMarkerConfig.getConfiguration(); Template template = configuration.getTemplate(\"item.ftl\"); Map dataModel = new HashMap&lt;&gt;(); //1.加载商品表数据 TbGoods goods = goodsMapper.selectByPrimaryKey(goodsId); dataModel.put(\"goods\", goods); //2.加载商品扩展表数据 TbGoodsDesc goodsDesc = goodsDescMapper.selectByPrimaryKey(goodsId); dataModel.put(\"goodsDesc\", goodsDesc); //3.商品分类 String itemCat1 = itemCatMapper.selectByPrimaryKey(goods.getCategory1Id()).getName(); String itemCat2 = itemCatMapper.selectByPrimaryKey(goods.getCategory2Id()).getName(); String itemCat3 = itemCatMapper.selectByPrimaryKey(goods.getCategory3Id()).getName(); dataModel.put(\"itemCat1\", itemCat1); dataModel.put(\"itemCat2\", itemCat2); dataModel.put(\"itemCat3\", itemCat3); Writer out = new FileWriter(\"d:\\\\item\\\\\" + goodsId + \".html\"); template.process(dataModel, out); out.close(); return true; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return false; &#125; &#125;&#125; 修改模板，展示商品分类面包屑 12345&lt;ul class=&quot;sui-breadcrumb&quot;&gt;&lt;li&gt;&lt;a href=&quot;#&quot;&gt;$&#123;itemCat1&#125;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#&quot;&gt;$&#123;itemCat2&#125;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#&quot;&gt;$&#123;itemCat3&#125;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 商品详情页-前端逻辑购买数量加减操作加入 angularJS 库将 angularJS 库加入 d:\\item 下 前端控制层将 base.js 拷贝到 js 目录下在 js 目录下构建 controller 文件夹，创建 itemController.js 12345678910111213//商品详细页（控制层）app.controller('itemController', function($scope)&#123; //数量操作 $scope.addNum = function(x) &#123; $scope.num = $scope.num + x; if($scope.num &lt; 1) &#123; $scope.num = 1; &#125; &#125;&#125;); 在方法中控制数量不能小于 1 模板引入 js 123&lt;script type=&quot;text/javascript&quot; src=&quot;plugins/angularjs/angular.min.js&quot;&gt; &lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/base.js&quot;&gt; &lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/controller/itemController.js&quot;&gt; &lt;/script&gt; 添加指令 1&lt;body ng-app=&quot;pinyougou&quot; ng-controller=&quot;itemController&quot; ng-init=&quot;num=1&quot;&gt; 调用操作数量的方法 12345&lt;div class=&quot;controls&quot;&gt;&lt;input autocomplete=&quot;off&quot; type=&quot;text&quot; value=&quot;&#123;&#123;num&#125;&#125;&quot; minnum=&quot;1&quot; class=&quot;itxt&quot; /&gt;&lt;a href=&quot;javascript:void(0)&quot; class=&quot;increment plus&quot; ng-click=&quot;addNum(1)&quot; &gt;+&lt;/a&gt;&lt;a href=&quot;javascript:void(0)&quot; class=&quot;increment mins&quot; ng-click=&quot;addNum(-1)&quot;&gt;-&lt;/a&gt;&lt;/div&gt; 两种循环对比： 排序 插值，生成字符串要用单引号表示，数值不需要 这是浅克隆 需要修改 用非作为匹配 map1是key，map2是值 匹配sku","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"Day11_SearchByPrice","date":"2019-07-18T01:07:39.406Z","updated":"2018-12-13T12:19:14.000Z","comments":true,"path":"2019/07/18/Day11_SearchByPrice/","link":"","permalink":"http://yoursite.com/2019/07/18/Day11_SearchByPrice/","excerpt":"","text":"搜索解决方案-Solr 【3】课程目标目标 1：实现品优购价格区间筛选功能目标 2：实现搜索结果分页功能目标 3：理解多关键字搜索目标 4：实现搜索结果排序功能目标 5：实现隐藏品牌列表功能目标 6：实现搜索页与首页对接功能目标 7：完成更新索引库的功能 1.按价格区间筛选1.1 需求分析点击搜索面板上的价格区间，实现按价格筛选 1.2 前端代码1.2.1 前端控制层（1）修改 pinyougou-search-web 的 searchController.js 搜索条件的定义 12$scope.searchMap=&#123;'keywords':'','category':'','brand':'','spec':&#123;&#125;,'price':'' &#125;;//搜索条件封装对象 （2）修改 pinyougou-search-web 的 searchController.js 添加搜索项和删除搜索项的方法//添加搜索项$scope.addSearchItem=function(key,value){ 就是判断当前页所展示页码是否到头欧哲是否到尾，否则为false并赋值给变量，前端判断这个变量 高亮页码：判断当前页码是否等于点击的显示页签 搜索后页面从1开始： 按价格排序（升序 降序）12Sort sort=new Sort(枚举值,排序字段)query.addSort(sort); 排序不能写死，可以写活 先在前段里加条件结构 再后台代码判断 写Controller 按新品排序设置solr中的schema,添加新列 重新导入数据库到solr 增加实体类，重新执行导入操作（假如log4j,因为dao层使用里log4j,没使用可以不加） quarzt定时任务框架 业余了解 将搜索功能整合到首页思路： 12index页面传递参数（关键词）给搜索搜索页接收并查询 这里的search（）方法是传递 控制器需要有local服务 加载关键字 批量审核数据到solr 下面这样可以省去写循环","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"Day10_Search","date":"2019-07-18T01:07:39.392Z","updated":"2018-12-13T12:19:14.000Z","comments":true,"path":"2019/07/18/Day10_Search/","link":"","permalink":"http://yoursite.com/2019/07/18/Day10_Search/","excerpt":"","text":"搜索解决方案-Solr品优购-高亮显示后端代码修改服务层代码 ItemSearchServiceImpl.java创建私有方法，用于返回查询列表的结果（高亮） 高亮结果处理不能用page.getContent，否则返回的是原生结果 需要用page.getHighlighted()高亮入口即可 12345678910111213141516171819202122232425262728293031/*** 根据关键字搜索列表* @param keywords* @return*/private Map searchList(Map searchMap)&#123; Map map = new HashMap(); HighlightQuery query = new SimpleHighlightQuery();//HighlightQuery是Query子类 HighlightOptions highlightOptions=new HighlightOptions().addField(\"item_title\");//设置高亮的域 highlightOptions.setSimplePrefix(\"&lt;em style='color:red'&gt;\");//高亮前缀 highlightOptions.setSimplePostfix(\"&lt;/em&gt;\");//高亮后缀 query.setHighlightOptions(highlightOptions);//为查询对象设置高亮选项 //按照关键字查询 Criteria criteria = new Criteria(\"item_keywords\").is(searchMap.get(\"keywords\")); query.addCriteria(criteria); HighlightPage&lt;TbItem&gt; page = solrTemplate.queryForHighlightPage(query, TbItem.class);//返回高亮页对象 for(HighlightEntry&lt;TbItem&gt; h : page.getHighlighted()) //循环高亮入口集合 &#123; TbItem item = h.getEntity();//获取原实体类 也就是当前对象每个结果集 if(h.getHighlights().size() &gt; 0 &amp;&amp; h.getHighlights().get(0).getSnipplets().size() &gt; 0)//判断有没有元素 &#123; item.setTitle(h.getHighlights().get(0).getSnipplets().get(0));//设置高亮的结果添加到标题 &#125; &#125; map.put(\"rows\", page.getContent()); return map;&#125; 为什么有这么多集合，有可能存在多域，每个域中可能存在多行值，例如复制域 修改 ItemSearchServiceImpl 的 search 方法，调用刚才编写的私有方法 12345678@Overridepublic Map&lt;String, Object&gt; search(Map searchMap)&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //1.查询列表 map.putAll(searchList(searchMap)); return map;&#125; 前端代码为什么设置高亮后没解析HTML高亮呢？ 12345 我们测试后发现高亮显示的 html 代码原样输出，这是 angularJS 为了防止 html 攻击采取的安全机制。我们如何在页面上显示 html 的结果呢？我们会用到$sce 服务的 trustAsHtml 方法来实现转换。 因为这个功能具有一定通用性，我们可以通过 angularJS 的过滤器来简化开发，这样只写一次，调用的时候就非常方便了，看代码 （1）修改 base.js 12345678910// 定义模块:var app = angular.module(\"pinyougou\", []);/*$sce 服务写成过滤器 '$sce'加载 function传入*/app.filter('trustHtml', ['$sce', function($sce)&#123; return function(data) &#123; return $sce.trustAsHtml(data); &#125;&#125;]); （2）使用过滤器 ng-bind-html 指令用于显示 html 内容竖线 |用于调用过滤器 1&lt;div class=\"attr\" ng-bind-html=\"item.title | trustHtml\"&gt;&lt;/div&gt; 搜索业务实现思路（1）搜索面板的商品分类需要使用 Spring Data Solr 的分组查询来实现（2）为了能够提高查询速度，我们需要把查询面板的品牌、规格数据提前放入 redis（3）查询条件的构建、面板的隐藏需要使用 angularJS 来实现（4）后端的分类、品牌、规格、价格区间查询需要使用spring data solr过滤查询来实现 查询分类列表根据搜索关键字查询商品分类名称列表 后端代码修改 SearchItemServiceImpl.java 创建方法 分组需指定要分组的域 123456789101112131415161718192021222324252627282930313233/*** 查询分类列表* @param searchMap* @return*/private List searchCategoryList(Map searchMap)&#123; List&lt;String&gt; list = new ArrayList(); Query query = new SimpleQuery();//第二步 需要加条件 //按照关键字查询 Criteria criteria = new Criteria(\"item_keywords\").is(searchMap.get(\"keywords\"));//第三添加条件 query.addCriteria(criteria); //设置分组选项 GroupOptions groupOptions = new GroupOptions().addGroupByField(\"item_category\"); query.setGroupOptions(groupOptions);//第四设置分组发现要先new //得到分组页 GroupPage&lt;TbItem&gt; page = solrTemplate.queryForGroupPage(query, TbItem.class);//第一步 分页查询 发现需要query //page.getContent会得到空值 这个方法用不到但由于子类而有的 //可以通过page.getGroupResult获取结果集 //根据列得到分组结果集 GroupResult&lt;TbItem&gt; groupResult = page.getGroupResult(\"item_category\"); //得到分组结果入口页 Page&lt;GroupEntry&lt;TbItem&gt;&gt; groupEntries = groupResult.getGroupEntries(); //得到分组入口集合 groupEntries分口入口页才能用getContent() List&lt;GroupEntry&lt;TbItem&gt;&gt; content = groupEntries.getContent(); for(GroupEntry&lt;TbItem&gt; entry : content) &#123; list.add(entry.getGroupValue());//将分组结果的名称封装到返回值中 &#125; return list;&#125; search 方法调用 1234567891011@Overridepublic Map&lt;String, Object&gt; search(Map searchMap)&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //1.按关键字查询（高亮显示） ...... //2.根据关键字查询商品分类 List categoryList = searchCategoryList(searchMap); map.put(\"categoryList\", categoryList); return map;&#125; 前端代码修改 search.html 123456789&lt;div class=\"type-wrap\" ng-if=\"resultMap.categoryList!=null\"&gt; &lt;div class=\"fl key\"&gt; 商品分类 &lt;/div&gt; &lt;div class=\"fl value\"&gt; &lt;span ng-repeat=\"category in resultMap.categoryList\"&gt;&lt;a href=\"#\"&gt;&#123;&#123;category&#125;&#125;&lt;/a&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"fl ext\"&gt;&lt;/div&gt;&lt;/div&gt; 缓存品牌和规格数据将商品分类数据、品牌数据、和规格数据都放入 Redis 存储。（1）当用户进入运营商后台的商品分类页面时，将商品分类数据放入缓存（Hash）。以分类名称作为 key ,以模板 ID 作为值（2）当用户进入运营商后台的模板管理页面时，分别将品牌数据和规格数据放入缓存（Hash）。以模板 ID 作为 key,以品牌列表和规格列表作为值 缓存实例数据结构： 进行增删改时候都要进行更新，教程里增删改后都会进行分类管理界面刷新，因此做在查询里面即可。因为增删改后都会利用到查询方法。 缓存商品分类数据将商品分类表存入缓存 pinyougou-sellergoods-service 工程需要引入 pinyougou-common 工程依赖。修改 pinyougou-sellergoods-service 的 ItemCatServiceImpl.java，添加 redisTemplate 123456789101112131415161718192021222324252627@Autowiredprivate RedisTemplate redisTemplate;/*** 根据上级 ID 查询列表*/@Overridepublic List&lt;TbItemCat&gt; findByParentId(Long parentId)&#123; TbItemCatExample example1 = new TbItemCatExample(); //条件查询 Criteria criteria1 = example1.createCriteria(); criteria1.andParentIdEqualTo(parentId); //每次执行查询的时候，一次性读取缓存进行存储 (因为每次增删改都要执行此方法) //获取所有的分类 List&lt;TbItemCat&gt; list = findAll(); //遍历获取分类明细 for(TbItemCat itemCat : list) &#123; //将模板ID放进缓存（以名称为key） //hash采用boundHashOps(\"name\").put(key,value) redisTemplate.boundHashOps(\"itemCat\").put(itemCat.getName(), itemCat.getTypeId()); &#125; System.out.println(\"更新缓存:商品分类表\"); return itemCatMapper.selectByExample(example1);&#125; 缓存品牌和规格列表数据修改 pinyougou-sellergoods-service 的 TypeTemplateServiceImpl.java 123456789101112131415161718192021@Autowiredprivate RedisTemplate redisTemplate;/*** 将数据存入缓存*/private void saveToRedis()&#123; //获取模板数据 List&lt;TbTypeTemplate&gt; typeTemplateList = findAll(); //循环模板 for(TbTypeTemplate typeTemplate : typeTemplateList) &#123; //存储品牌列表 List&lt;Map&gt; brandList = JSON.parseArray(typeTemplate.getBrandIds(),Map.class); redisTemplate.boundHashOps(\"brandList\").put(typeTemplate.getId(),brandList); //存储规格列表 List&lt;Map&gt; specList = findSpecList(typeTemplate.getId()); //根据模板 ID 查询规格列表 redisTemplate.boundHashOps(\"specList\").put(typeTemplate.getId(),specList); &#125;&#125; 在查询分页方法(findPage) 时调用此方法 123456public PageResult findPage(TbTypeTemplate typeTemplate, int pageNum, int pageSize)&#123; ...... saveToRedis();//存入数据到缓存 return new PageResult(page.getTotal(), page.getResult());&#125; 加载缓存数据启动 redis ,运行运营商管理后台，打开商品分类和模板管理页，即可将数据放入缓存中。 显示品牌和规格数据在搜索面板区域显示第一个分类的品牌和规格列表 后端代码修改 ItemSearchServiceImpl.java ，增加方法 1234567891011121314151617181920212223@Autowiredprivate RedisTemplate redisTemplate;/*** 查询品牌和规格列表* @param category 分类名称* @return*/private Map searchBrandAndSpecList(String category)&#123; Map map = new HashMap(); //1.根据商品分类名称获得模板ID Long typeId = (Long) redisTemplate.boundHashOps(\"itemCat\").get(category);//获取模板 ID if(typeId != null)//注要是为了容错 &#123; //2.根据模板 ID 获取品牌列表 List brandList = (List)redisTemplate.boundHashOps(\"brandList\").get(typeId); map.put(\"brandList\", brandList);//返回值添加品牌列表 //3.根据模板 ID 获取规格列表 List specList = (List)redisTemplate.boundHashOps(\"specList\").get(typeId); map.put(\"specList\", specList); &#125; return map;&#125; Search 方法调用此方法（注意跟视频有点不同） 12345678910111213@Overridepublic Map&lt;String, Object&gt; search(Map searchMap)&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //1.按关键字查询（高亮显示） //2.根据关键字查询商品分类 //3.查询品牌和规格列表 if(categoryList.size() &gt; 0)//容错 &#123; map.putAll(searchBrandAndSpecList(categoryList.get(0))); &#125; return map;&#125; 前端代码获取品牌列表修改页面 search.html，实现品牌列表 12345678910111213&lt;div class=\"type-wrap logo\" ng-if=\"resultMap.brandList!=null\"&gt; &lt;div class=\"fl key brand\"&gt; 品牌 &lt;/div&gt; &lt;div class=\"value logos\"&gt; &lt;ul class=\"logo-list\"&gt; &lt;li ng-repeat=\"brand in resultMap.brandList\"&gt;&#123;&#123;brand.text&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"ext\"&gt; &lt;a href=\"javascript:void(0);\" class=\"sui-btn\"&gt;多选&lt;/a&gt; &lt;a href=\"javascript:void(0);\"&gt;更多&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 获取规格列表修改页面 search.html，实现规格列表 12345678910111213&lt;div class=\"type-wrap\" ng-repeat=\"spec in resultMap.specList\"&gt; &lt;div class=\"fl key\"&gt; &#123;&#123;spec.text&#125;&#125; &lt;/div&gt; &lt;div class=\"fl value\"&gt; &lt;ul class=\"type-list\"&gt; &lt;li ng-repeat=\"pojo in spec.options\"&gt; &lt;a&gt;&#123;&#123;pojo.optionName&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"fl ext\"&gt;&lt;/div&gt;&lt;/div&gt; 过滤条件构建点击搜索面板上的分类、品牌和规格，实现查询条件的构建。查询条件以面包屑的形式显示。当面包屑显示分类、品牌和规格时，要同时隐藏搜索面板对应的区域。用户可以点击面包屑上的 X 撤销查询条件。撤销后显示搜索面包相应的区域 添加搜索项修改 pinyougou-search-web 的 searchController.js 1234567891011121314151617181920//定义搜索对象结构$scope.searchMap =&#123; 'keywords': '', 'category': '', 'brand': '', 'spec': &#123;&#125;&#125;; //搜索对象//添加搜索项$scope.addSearchItem = function (key, value)&#123; if (key == 'category' || key == 'brand') &#123; //如果点击的是分类或者是品牌 $scope.searchMap[key] = value;//key传递因此保持一致 &#125; else &#123; $scope.searchMap.spec[key] = value;//规格有多个 &#125;&#125; 搜索对象的结构 点击搜索项修改 pinyougou-search-web 的 search.html ，为搜索面板添加点击事件 123456789点击商品分类标签&lt;a href=\"#\" ng-click=\"addSearchItem('category',category)\"&gt;&#123;&#123;category&#125;&#125;&lt;/a&gt;点击品牌标签&lt;a href=\"#\" ng-click=\"addSearchItem('brand',brand.text)\"&gt;&#123;&#123;brand.text&#125;&#125;&lt;/a&gt;点击规格标签&lt;a href=\"#\" ng-click=\"addSearchItem(spec.text,pojo.optionName)\"&gt;&#123;&#123;pojo.optionName&#125;&#125;&lt;/a&gt; 这个要多理解下 saveBeans跟saveBean区别saveBean只是保存对象 saveBeans可以保存数组","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"Day09_Solr","date":"2019-07-18T01:07:39.381Z","updated":"2018-12-13T12:19:14.000Z","comments":true,"path":"2019/07/18/Day09_Solr/","link":"","permalink":"http://yoursite.com/2019/07/18/Day09_Solr/","excerpt":"","text":"Solr 安装1：安装 Tomcat，解压缩即可。 2：解压 solr。3：把 solr 下的 dist 目录 solr-4.10.3.war 部署到 Tomcat\\webapps 下(去掉版本号)。 如果tomcat在运行时添加或删除war包webapp也会相应创建或删除网站目录，应当关闭tomcat后删除war包。 4：启动 Tomcat 解压缩 war 包5：把solr下example/lib/ext 目录下的所有的 jar 包，添加到 solr 的工程中(\\WEB-INF\\lib目录下)。6：创建一个 solrhome 。solr 下的/example/solr 目录就是一个 solrhome。复制此目录到 D 盘改名为 solrhome7：关联 solr 及 solrhome。需要修改 solr 工程的 web.xml 文件。 12345&lt;env-entry&gt; &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt; &lt;env-entry-value&gt;d:\\solrhome&lt;/env-entry-value&gt; &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;&lt;/env-entry&gt; 8：启动 Tomcathttp://IP:8080/solr/ 中文分析器 IK AnalyzerIK Analyzer 简介IK Analyzer 是一个开源的，基亍 java 语言开发的轻量级的中文分词工具包。从 2006年 12 月推出 1.0 版开始， IKAnalyzer 已经推出了 4 个大版本。最初，它是以开源项目Luence 为应用主体的，结合词典分词和文法分析算法的中文分词组件。从 3.0 版本开始，IK 发展为面向 Java 的公用分词组件，独立亍 Lucene 项目，同时提供了对 Lucene 的默认优化实现。在 2012 版本中，IK 实现了简单的分词歧义排除算法，标志着 IK 分词器从单纯的词典分词向模拟语义分词衍化 IK Analyzer 配置步骤：1、把 IKAnalyzer2012FF_u1.jar 添加到 solr 工程的 lib 目录下2、创建 WEB-INF/classes 文件夹 把扩展词典、停用词词典、配置文件放到 solr 工程的 WEB-INF/classes 目录下。3、修改 Solrhome 的 schema.xml 文件，配置一个 FieldType，使用 IKAnalyzer 123&lt;fieldType name=\"text_ik\" class=\"solr.TextField\"&gt; &lt;analyzer class=\"org.wltea.analyzer.lucene.IKAnalyzer\"/&gt;&lt;/fieldType&gt; 普通分词： Solr域配置域域相当于数据库的表字段，用户存放数据，因此用户根据业务需要去定义相关的 Field（域），一般来说，每一种对应着一种数据，用户对同一种数据进行相同的操作。域的常用属性： name：指定域的名称 type：指定域的类型 indexed：是否索引 stored：是否存储 required：是否必须 multiValued：是否多值 Solr将查询后需要显示内容都存进去，否则要Solr有何用。 每行field都是域 这次demo出错：没有配置域造成注解无效 demo准备1：修改 solrhome 的 schema.xml 文件 设置业务系统 Field 1234567&lt;field name=\"item_goodsid\" type=\"long\" indexed=\"true\" stored=\"true\"/&gt;&lt;field name=\"item_title\" type=\"text_ik\" indexed=\"true\" stored=\"true\"/&gt;&lt;field name=\"item_price\" type=\"double\" indexed=\"true\" stored=\"true\"/&gt;&lt;field name=\"item_image\" type=\"string\" indexed=\"false\" stored=\"true\" /&gt;&lt;field name=\"item_category\" type=\"string\" indexed=\"true\" stored=\"true\" /&gt;&lt;field name=\"item_seller\" type=\"text_ik\" indexed=\"true\" stored=\"true\" /&gt;&lt;field name=\"item_brand\" type=\"string\" indexed=\"true\" stored=\"true\" /&gt; stored是否储存，required是否必填，indexed是否搜索，multiValue是否带多值，type=“text_ik”代表字段使用中文分词器，name值同前端显示的name值对应 一般不会使用它配好带域 而是使用自定义，根据需求定义 案例需要： id、title、price、brand、seller、image、catagory、goodssid(商品spu id) 因为我们点进去产品需要sku id查询 分析是否需要搜索（indexed）： 12345678910id SKUtitle 标题 Yprice 价格 Yimage 图片地址 Nbrand 品牌 Yseller 商家名 Ycategory 商品分类 Ygoodsid 商品SPU Y商品SPU有时候还是需要的 因此还是改成Y (true) 复制域复合域：几个列在一次，多列组合 复制域逻辑上的整合，不需要stored，需要multiValue source从哪拷贝 dest目标值 下列item_keywords就是几个copyField的复制域，一个相当于多个域 demo准备2：修改 solrhome 的 schema.xml 文件 设置业务系统 Field 12345&lt;field name=\"item_keywords\" type=\"text_ik\" indexed=\"true\" stored=\"false\" multiValued=\"true\"/&gt;&lt;copyField source=\"item_title\" dest=\"item_keywords\"/&gt;&lt;copyField source=\"item_category\" dest=\"item_keywords\"/&gt;&lt;copyField source=\"item_seller\" dest=\"item_keywords\"/&gt;&lt;copyField source=\"item_brand\" dest=\"item_keywords\"/&gt; 动态域如规格，配置(配置好后重新启动)： 1&lt;dynamicField name=\"item_spec_*\" type=\"string\" indexed=\"true\" stored=\"true\" /&gt; SpringDataSolr虽然支持任何编程语言的能力具有很大的市场价值，你可能感兴趣的问题是：我如何将Solr 的应用集成到 Spring 中？可以，Spring Data Solr 就是为了方便 Solr 的开发所研制的一个框架，其底层是对 SolrJ（官方 API）的封装。 官方类库 solrJ 原理：http请求与响应 SpringDataSolr 原理：就是对官方类库对封装 手动请求solr 手动处理响应httpClient 搭建demo创建 maven 工程，pom.xml 中引入依赖 1234567891011121314151617&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-solr&lt;/artifactId&gt; &lt;version&gt;1.5.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-test&lt;/artifactId&gt;&lt;version&gt;4.2.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;junit&lt;/groupId&gt;&lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;version&gt;4.9&lt;/version&gt;&lt;/dependency&gt; &lt;/dependencies&gt; 在 src/main/resources 下创建 applicationContext-solr.xml 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:solr=\"http://www.springframework.org/schema/data/solr\" xsi:schemaLocation=\"http://www.springframework.org/schema/data/solr http://www.springframework.org/schema/data/solr/spring-solr-1.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- solr服务器地址 就是tomcat中solr地址 --&gt; &lt;solr:solr-server id=\"solrServer\" url=\"http://127.0.0.1:8080/solr\" /&gt; &lt;!-- solr模板，使用solr模板可对索引库进行CRUD的操作 --&gt; &lt;bean id=\"solrTemplate\" class=\"org.springframework.data.solr.core.SolrTemplate\"&gt; &lt;!-- 构造参数 构造器注入参数--&gt; &lt;constructor-arg ref=\"solrServer\" /&gt; &lt;/bean&gt;&lt;/beans&gt; @Field 注解创建 cn.itcast.pojo 包，将品优购的 TbItem 实体类拷入本工程 ,属性使用@Field 注解标识 。如果属性与配置文件定义的域名称不一致，需要在注解中指定域名称。 12345678910111213141516171819public class TbItem implements Serializable &#123; @Field // 由于默认solr里也是id，因此可以省略不写关联词 private Long id; @Field(\"item_title\") private String title; @Field(\"item_price\") private BigDecimal price; @Field(\"item_image\") private String image; @Field(\"item_goodsid\") private Long goodsId; @Field(\"item_category\") private String category; @Field(\"item_brand\") private String brand; @Field(\"item_seller\") private String seller; ....... &#125; 创建测试类 TestTemplate.java 123456789101112131415161718192021@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:applicationContext-solr.xml\") public class TestTemplate &#123; //先注入solrTemplate @Autowired private SolrTemplate solrTemplate; @Test public void testAdd() &#123; TbItem item = new TbItem(); item.setId(1L); item.setBrand(\"华为\"); item.setCategory(\"手机\"); item.setGoodsId(1L); item.setSeller(\"华为 2 号专卖店\"); item.setTitle(\"华为 Mate9\"); item.setPrice(new BigDecimal(2000.01));// 实体类是浮点型 solrTemplate.saveBean(item);// 保存 solrTemplate.commit(); // 提交 &#125; &#125; 测试前确保solr启动过的，第二次存id一样的情况就是修改 BigDecimal高精度：用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数。在实际应用中，需要对更大或者更小的数进行运算和处理。 按主键查询删除123456789101112@Test public void testFindOne() &#123; TbItem item = solrTemplate.getById(1, TbItem.class); // 根据主键查询 第二个参数自动转换类型 System.out.println(item.getTitle()); &#125; @Test public void testDelete() &#123; solrTemplate.deleteById(\"1\"); // 根据主键删除 solrTemplate.commit(); &#125; 分页查询首先循环插入 100 条测试数据 1234567891011121314151617@Test public void testAddList() &#123; List&lt;TbItem&gt; list = new ArrayList(); for (int i = 0; i &lt; 100; i++) &#123; TbItem item = new TbItem(); item.setId(i + 1L); item.setBrand(\"华为\"); item.setCategory(\"手机\"); item.setGoodsId(1L); item.setSeller(\"华为 2 号专卖店\"); item.setTitle(\"华为 Mate\" + i); item.setPrice(new BigDecimal(2000 + i)); list.add(item); &#125; solrTemplate.saveBeans(list); solrTemplate.commit(); &#125; 编写分页查询测试代码： 123456789101112131415161718@Test public void testPageQuery() &#123; Query query = new SimpleQuery(\"*:*\"); //构建一个查询对象 *:*表示查询所有 前面*表示字段 后面*表示值 域名:值 query.setOffset(20);// 开始索引（默认 0）Offset英文含义便宜 query.setRows(20);// 每页记录数(默认 10) ScoredPage&lt;TbItem&gt; page = solrTemplate.queryForPage(query, TbItem.class); System.out.println(\"总记录数：\" + page.getTotalElements()); List&lt;TbItem&gt; list = page.getContent(); showList(list); &#125; // 显示记录数据 private void showList(List&lt;TbItem&gt; list) &#123; for (TbItem item : list) &#123; System.out.println(item.getTitle() + item.getPrice()); &#125; &#125; 下图没做分页(注意：page.getContent()为List)： 12345678@Testpublic void testPageQ() &#123; SimpleQuery query = new SimpleQuery(\"*:*\"); ScoredPage&lt;TbItem&gt; page = solrTemplate.queryForPage(query, TbItem.class); for (TbItem item : page.getContent()) &#123; System.out.println(item.getTitle()+item.getBrand()); &#125; &#125; 而分页就是加上Query 条件查询Criteria 用于对条件的封装： 12345678910111213141516@Testpublic void testPageQueryMutil()&#123; Query query = new SimpleQuery(\"*:*\"); Criteria criteria = new Criteria(\"item_title\").contains(\"2\"); //第一个括号要查询字段 第二个包含 criteria = criteria.and(\"item_title\").contains(\"5\"); //and条件的拼接 query.addCriteria(criteria); //query.setOffset(20);//开始索引（默认 0） //query.setRows(20);//每页记录数(默认 10) ScoredPage&lt;TbItem&gt; page = solrTemplate.queryForPage(query, TbItem.class); System.out.println(\"总记录数：\" + page.getTotalElements()); List&lt;TbItem&gt; list = page.getContent(); showList(list);&#125; 删除全部数据1234567@Testpublic void testDeleteAll()&#123; Query query = new SimpleQuery(\"*:*\"); //没有Criteria条件时候冒号星一定要写 solrTemplate.delete(query); solrTemplate.commit();&#125; 品优购-批量数据导入编写专门的导入程序，将商品数据导入到 Solr 系统中，百度也可搜索到专用数据导入插件。 工程搭建（1）创建 pinyougou-solr-util（jar） ,引入 pinyougou-dao 以及 spring 相关依赖（找service里相关依赖） spring相关依赖从其他service里复制来即可 （2）创建 spring 配置文件applicationContext包扫描（复制来）内容是： 12&lt;context:component-scan base-package=\"com.pinyougou.solrutil\"&gt;&lt;/context:component-scan&gt; 创建 com.pinyougou.solrutil 包，创建类 SolrUtil ,实现商品数据的查询(已审核商品) 1234567891011121314151617181920212223242526272829303132333435//把普通pojo实例化到spring容器中 配置文件中也有配置@Componentpublic class SolrUtil&#123; @Autowired private TbItemMapper itemMapper; /** * 导入商品数据 */ public void importItemData() &#123; TbItemExample example = new TbItemExample(); Criteria criteria = example.createCriteria();//创建条件 criteria.andStatusEqualTo(\"1\");//已审核 List&lt;TbItem&gt; itemList = itemMapper.selectByExample(example); System.out.println(\"===商品列表===\"); for(TbItem item : itemList) &#123; System.out.println(item.getTitle()); &#125; System.out.println(\"===结束===\"); &#125; //main方法 public static void main(String[] args) &#123; //用spring进行管理 先加载配置文件 常规查询 //不用spring容器管理的不能用 @Autowired ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath*:spring/applicationContext*.xml\"); //第二个路径*扩大路径的范围 可以匹配其他模块里的文件 //classpath*扫描jar包里的配置文件加 因为dao是jar的 SolrUtil solrUtil = (SolrUtil) context.getBean(\"solrUtil\"); solrUtil.importItemData(); &#125;&#125; （main方法不输出结果方法）上图这种要加log4j的依赖jar包 数据导入 Solr 索引库实体类（1）将 demo 工程中添加了@Field 注解的实体类拷贝到 pinyougou-pojo 中会报错 此时导入依赖（2）在 pinyougou-pojo 中引入依赖，然后install 为什么不用solrJ是因为以后项目要其他注解solrJ没有 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-solr&lt;/artifactId&gt; &lt;version&gt;1.5.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 添加 Solr 配置文件添加 applicationContext-solr.xml 到 spring 目录（demo里的配置文件直接复制到util中） 123456&lt;!-- solr 服务器地址 --&gt;&lt;solr:solr-server id=\"solrServer\" url=\"http://127.0.0.1:8080/solr\" /&gt;&lt;!-- solr 模板，使用 solr 模板可对索引库进行 CRUD 的操作 --&gt;&lt;bean id=\"solrTemplate\" class=\"org.springframework.data.solr.core.SolrTemplate\"&gt;&lt;constructor-arg ref=\"solrServer\" /&gt;&lt;/bean&gt; 调用模板类导入 solr修改 pinyougou-solr-util 的 SolrUtil.java 1234567891011121314151617181920@Autowiredprivate SolrTemplate solrTemplate;/*** 导入商品数据*/public void importItemData()&#123; TbItemExample example = new TbItemExample(); Criteria criteria = example.createCriteria(); criteria.andStatusEqualTo(\"1\");//已审核 List&lt;TbItem&gt; itemList = itemMapper.selectByExample(example); System.out.println(\"===商品列表===\"); for(TbItem item : itemList) &#123; System.out.println(item.getTitle()); &#125; solrTemplate.saveBeans(itemList); //批量导入 solrTemplate.commit(); System.out.println(\"===结束===\");&#125; 规格-导入动态域@Dynamic 注解修改 TbItem.java ，添加属性 1234567891011@Dynamic@Field(\"item_spec_*\")private Map&lt;String, String&gt; specMap;public Map&lt;String, String&gt; getSpecMap()&#123; return specMap;&#125;public void setSpecMap(Map&lt;String, String&gt; specMap)&#123; this.specMap = specMap;&#125; 修改导入工具修改 pinyougou-solr-util 的 SolrUtil.java ,引入 fastJSON 依赖 123456789101112131415161718192021/*** 导入商品数据*/public void importItemData()&#123; TbItemExample example = new TbItemExample(); Criteria criteria = example.createCriteria(); criteria.andStatusEqualTo(\"1\");//已审核 List&lt;TbItem&gt; itemList = itemMapper.selectByExample(example); System.out.println(\"===商品列表===\"); for(TbItem item : itemList) &#123; Map specMap = JSON.parseObject(item.getSpec()); //将 spec 字段中的 json 字符 串转换为 map item.setSpecMap(specMap);//给带注解的字段赋值 System.out.println(item.getTitle()); &#125; solrTemplate.saveBeans(itemList); solrTemplate.commit(); System.out.println(\"===结束===\");&#125; 品优购-关键字搜索后端服务接口层代码服务接口层（1）创建 pinyougou-search-interface 模块（搜索服务接口 jar），依赖 pinyougou-pojo（2）创建 com.pinyougou.search.service 包，创建业务接口，依赖pinyougou-search-interface 12345678910public interface ItemSearchService&#123; /** * 搜索 * @param keywords * @return */ public Map&lt;String, Object&gt; search(Map searchMap); //List不能满足需要，因为今后搜索业务更复杂 不止是搜索关键词 搜索词 多个且不确定&#125; 服务实现层（1）创建 war 工程 pinyougou-search-service ，引入 pinyougou-search-interface springdubbox 等相关依赖（参加其它服务工程）Tomcat 运行端口 9004 从sellerservice中复制依赖，不需要dao的依赖，tomcat7端口9004 （2）添加 web.xml （参加其它服务工程）（3）在 src/main/resources/spring 下 applicationContext-service.xml （参见其它服务工程）dubbo 端口 20884（这是本机出去的端口）还需要修改扫描包package路径（4）在 src/main/resources/spring 下创建 spring 配置文件 applicationContext-solr.xml（同demo 工程） 注意：不用配置spring data solr是因为依赖传递，该模块依赖接口，接口依赖pojo 因为pojo中需要加solr注解，因此solr jar包依赖写在这里面 （5）编写服务实现类 ItemSearchServiceImpl.java 1234567891011121314151617181920@Service(timeout = 3000) //超时可以省略public class ItemSearchServiceImpl implements ItemSearchService&#123; @Autowired private SolrTemplate solrTemplate; @Override public Map&lt;String, Object&gt; search(Map searchMap) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); Query query = new SimpleQuery(); //也可以new SimpleQuery(*:*)下面有条件可以省略 //添加查询条件 Criteria criteria = new Criteria(\"item_keywords\").is(searchMap.get(\"keywords\"));//is这是通过分词的 //item_keywords是复制域 query.addCriteria(criteria); ScoredPage&lt;TbItem&gt; page = solrTemplate.queryForPage(query, TbItem.class); map.put(\"rows\", page.getContent());//当前页数据给rows 设置大key为rows return map; &#125;&#125; 控制层（1）创建 pinyougou-search-web 工程 ，引入依赖（参见其它 web 模块），tomcat 运行端 口 9104（2）添加 web.xml （参加其它 web 工程,springmvc.xml中改包名）（3）添加配置文件 （内容参加其它 web 工程）（4）创建包 com.pinyougou.search.controller 编写控制器类 在执行搜索时候有时候会造成超时，solr默认是1s，这时候可以在@Reference上设置超时 @Reference(timeout = 3000) 也可以在service上配置，代码如上，推荐放服务层 特殊情况：如果service、controller中都配置里不同超时时间，以controller为准 123456789101112@RestController@RequestMapping(\"/itemsearch\")public class ItemSearchController&#123; @Reference private ItemSearchService itemSearchService; @RequestMapping(\"/search\") public Map&lt;String, Object&gt; search(@RequestBody Map searchMap ) &#123; return itemSearchService.search(searchMap); &#125;&#125; 前端代码拷贝资源web.xml配置欢迎页（可以配置多个 优先级从上到下）： 123&lt;welcome-file-list&gt; &lt;welcome-file&gt;search.html&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; 将 angularJS 拷贝到插件文件夹拷贝 base.js 到 js 文件夹（都从其他模块中拷贝） 服务层pinyougou-search-web 工程创建 searchService.js 12345678//搜索服务层app.service(\"searchService\", function($http)&#123; this.search = function(searchMap) &#123; return $http.post('itemsearch/search.do', searchMap); &#125;&#125;); 控制层pinyougou-search-web 工程 searchController.js 12345678910111213app.controller('searchController', function($scope, searchService)&#123; //搜索 $scope.search = function() &#123; searchService.search( $scope.searchMap ).success( function(response) &#123; $scope.resultMap = response; //搜索返回的结果 &#125; ); &#125;&#125;); 页面pinyougou-search-web 工程 search.html 12345678910111213141516171819202122232425262728293031323334353637383940引入 js&lt;script type=\"text/javascript\" src=\"plugins/angularjs/angular.min.js\"&gt; &lt;/script&gt;&lt;script type=\"text/javascript\" src=\"js/base.js\"&gt; &lt;/script&gt;&lt;script type=\"text/javascript\" src=\"js/service/searchService.js\"&gt; &lt;/script&gt;&lt;script type=\"text/javascript\" src=\"js/controller/searchController.js\"&gt; &lt;/script&gt;指定控制器&lt;body ng-app=\"pinyougou\" ng-controller=\"searchController\"&gt;绑定搜索框&lt;div class=\"input-append\"&gt;&lt;input type=\"text\" id=\"autocomplete\" ng-model=\"searchMap.keywords\" type=\"text\"class=\"input-error input-xxlarge\" /&gt;&lt;button class=\"sui-btn btn-xlarge btn-danger\" ng-click=\"search()\" type=\"button\"&gt;搜索&lt;/button&gt;&lt;/div&gt; 循环显示数据&lt;li class=\"yui3-u-1-5\" ng-repeat=\"item in resultMap.rows\"&gt; &lt;div class=\"list-wrap\"&gt; &lt;div class=\"p-img\"&gt; &lt;a href=\"item.html\" target=\"_blank\"&gt;&lt;img src=\"&#123;&#123;item.image&#125;&#125;\" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=\"price\"&gt; &lt;strong&gt;&lt;em&gt;￥&lt;/em&gt; &lt;i&gt;&#123;&#123;item.price&#125;&#125;&lt;/i&gt;&lt;/strong&gt; &lt;/div&gt; &lt;div class=\"attr\"&gt; &lt;em&gt;&#123;&#123;item.title&#125;&#125;&lt;/em&gt; &lt;/div&gt; &lt;div class=\"cu\"&gt; &lt;em&gt;&lt;span&gt;促&lt;/span&gt;满一件可参加超值换购&lt;/em&gt; &lt;/div&gt; &lt;div class=\"commit\"&gt; &lt;i class=\"command\"&gt;已有 2000 人评价&lt;/i&gt; &lt;/div&gt; &lt;div class=\"operate\"&gt; &lt;a href=\"success-cart.html\" target=\"_blank\" class=\"sui-btn btn-bordered btn-danger\"&gt;加入购物车&lt;/a&gt; &lt;a href=\"javascript:void(0);\" class=\"sui-btn btn-bordered\"&gt;对比&lt;/a&gt; &lt;a href=\"javascript:void(0);\" class=\"sui-btn btn-bordered\"&gt;关注&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/li&gt; 为什么用Result.rows? 接收的响应值就map，keywords是map里的key 这里为什么用spring不用静态方法new(直接new出来不能直接注入) 因为我们要用dao模块，用原生方式比较麻烦","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"Day17_CROS","date":"2019-07-18T01:07:39.345Z","updated":"2018-12-13T12:19:14.000Z","comments":true,"path":"2019/07/18/Day17_CROS/","link":"","permalink":"http://yoursite.com/2019/07/18/Day17_CROS/","excerpt":"","text":"跨域例如ajax在A网址请求B网址（端口不一样或协议也算不同域）的请求。基于安全机制浏览器一般默认拦截。那怎么才能让其实现呢。 jsop，主流的是cors，通过服务端跟前段的配置 cors：在服务器上指定哪个域名是安全的，只需配置即可 要求：什么是跨域请求，怎么配置 跨域请求异常报错 CORS(Cross-origin resource sharing)Cross-origin resource sharing跨域资源共享 IE10以下的不兼容cors,cors是w3c制定的一个标准。 写法，服务端Controoler 1response.setHeader(\"Access-Control-Allow-Origin\", \"http://localhost:9105\"); //此法方法不需要操作cookie,如果是*代表所有 如果想操作cookie，地址不能为*，要为确定值 1response.setHeader(\"Access-Control-Allow-Credentials\", \"true\");//操作cookie 前端异步请求里添加 1&#123;&apos;withCredentials&apos;:true&#125; 具体事例中：123456789101112131415//添加商品到购物车$scope.addToCart = function ()&#123; $http.get('http://localhost:9107/cart/addGoodsToCartList.do?itemId=' + $scope.sku.id + '&amp;num=' + $scope.num, &#123; 'withCredentials': true &#125; ).success( function (response) &#123; ....... &#125; );&#125; springMVC 的版本在 4.2 或以上版本直接在跨域方法上用注解实现，allowCredentials=”true” 可以缺省 1@CrossOrigin(origins=&quot;http://localhost:9105&quot;,allowCredentials=&quot;true&quot;) 购物车cart-web引入user-interface依赖，AddressController地址是被cart-web购物车调用，因此写在购物车中 通过用户ID查询地址，定义在 pinyougou-user-interface中AddressService接口，pinyougou-user-service实现类，控制层 123456@RequestMapping(\"/findListByLoginUser\")public List&lt;TbAddress&gt; findListByLoginUser()&#123; String userId = SecurityContextHolder.getContext().getAuthentication().getName(); return addressService.findListByUserId(userId);&#125; 前端直接调用即可，页面调用获取地址列表应该在页面打开后加载。ng-init调用查找地址方法。后端不要忘了给实体类实现序列化接口。 订单主键的生成为什么不用自增，因为在使用数据库分片时候自增会产生重复值 其他方案： UUID，不易排序、太长 Redis产生自增ID 但是主键生成需要访问Redis，依赖Redis Oracle数据库对象-序列 需要oracle数据库 程序自己写算法（保证不重复） 分布式ID生成器twitter开源的snowflake算法 将64位二进制数，转换为十进制数，按时间戳生成前面一段，毫秒值一样的情况加1。 保存操作服务实现类add方法： 从缓存提取购物车列表 循环购物车列表添加订单 清除缓存中的购物车 关于雪花util可以新建后使用也可以在bean中配置。构造器部署 123456&lt;bean id=\"idWorker\" class=\"util.IdWorker\"&gt;&lt;!-- 进程 ID --&gt; &lt;constructor-arg index=\"0\" value=\"0\"&gt;&lt;/constructor-arg&gt; &lt;!-- 数据中心 ID --&gt; &lt;constructor-arg index=\"1\" value=\"0\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;","categories":[],"tags":[],"keywords":[]},{"title":"spring cloud zuul网关的作用","slug":"框架","date":"2019-07-12T14:29:09.000Z","updated":"2019-07-12T15:50:11.803Z","comments":true,"path":"2019/07/12/框架/","link":"","permalink":"http://yoursite.com/2019/07/12/框架/","excerpt":"","text":"spring cloud zuul网关的作用1是类似于Nginx的网址重定向,但zuul的重定向的一般是整个spring cloud里在Eureka注册中心的模块. 2、zuul更重要的功能为过滤请求. solr如何实现搜索的？倒排索引，先抽取文档中词，并建立词与文档id的映射关系，然后查询的时候会根据词去查询文档id，并查询出文档 倒排索引源于实际应用中需要根据属性的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。 solr的索引查询为什么比数据库要快Solr使用的是Lucene API实现的全文检索。全文检索本质上是查询的索引。而数据库中并不是所有的字段都建立的索引，更何况如果使用like查询时很大的可能是不使用索引，所以使用solr查询时要比查数据库快","categories":[],"tags":[],"keywords":[]},{"title":"Maven 软件的安装","slug":"maven仓库与tomcat","date":"2019-07-12T14:29:09.000Z","updated":"2019-07-12T14:35:10.098Z","comments":true,"path":"2019/07/12/maven仓库与tomcat/","link":"","permalink":"http://yoursite.com/2019/07/12/maven仓库与tomcat/","excerpt":"","text":"Maven 软件的安装Apache-maven-3.5.2 下载地址：http://archive.apache.org/dist/maven/maven-3/ Maven 下载后，将 Maven 解压到一个没有中文没有空格的路径下，比如 D:\\software\\maven 下面。解压后目录结构如下： 12345bin:存放了 maven 的命令，比如我们前面用到的 mvn tomcat:runboot:存放了一些 maven 本身的引导程序，如类加载器等conf:存放了 maven 的一些配置文件，如 setting.xml 文件lib:存放了 maven 本身运行所需的一些 jar 包至此我们的 maven 软件就可以使用了，前提是你的电脑上之前已经安装并配置好了 JDK。 Maven 及 JDK 配置配置 MAVEN_HOME ，变量值就是你的 maven 安装 的路径（bin 目录之前一级目录） 同时不要忘记在Path中添加环境变量 1%MAVEN_HOME%\\bin Maven 软件版本测试通过命令行 mvn -v命令检查 maven 是否安装成功，看到 maven 的版本为 3.5.2 及 java 版本为 1.8 即为安装成功。 Maven 仓库的分类123456789本地仓库 ：用来存储从远程仓库或中央仓库下载的插件和 jar 包，项目使用一些插件或 jar 包，优先从本地仓库查找默认本地仓库位置在 $&#123;user.dir&#125;/.m2/repository，$&#123;user.dir&#125;表示 windows 用户目录。远程仓库：如果本地需要插件或者 jar 包，本地仓库没有，默认去远程仓库下载。远程仓库可以在互联网内也可以在局域网内。中央仓库 ：在 maven 软件中内置一个远程仓库地址 http://repo1.maven.org/maven2 ，它是中央仓库，服务于整个互联网，它是由 Maven 团队自己维护，里面存储了非常全的 jar 包，它包含了世界上大部分流行的开源项目构件 Maven 本地仓库的配置将已下载本地仓库 “repository.rar”解压至自己的电脑上，我们解压在 D:\\repository 目录下（可以放在没有中文及空格的目录下）。 在 MAVE_HOME/conf/settings.xml 文件中配置本地仓库位置（maven 的安装目录下）打开 settings.xml文件，配置如下： 全局 setting 与用户 settingmaven 仓库地址、私服等配置信息需要在 setting.xml 文件中配置，分为全局配置和用户配置。在 maven 安装目录下的有 conf/setting.xml 文件，此 setting.xml 文件用于 maven 的所有 project项目，它作为 maven 的全局配置。如需要个性配置则需要在用户配置中设置，用户配置的 setting.xml 文件默认的位置在：${user.dir}/.m2/settings.xml 目录中,${user.dir} 指 windows 中的用户目录。maven 会先找用户配置，如果找到则以用户配置文件为准，否则使用全局配置文件 idea 的 maven 配置打开File&gt;Settings 配置 maven选择本地 maven 安装目录，指定 maven 安装目录下 conf 文件夹中 settings 配置文件。 创建项目时这些不用改 坐标的来源方式从互联网搜索http://search.maven.org/http://mvnrepository.com/ 依赖范围compile：编译范围，指 A 在编译时依赖 B，此范围为默认依赖范围。编译范围的依赖会用在编译、测试、运行，由于运行时需要所以编译范围的依赖会被打包。 provided：provided 依赖只有在当 JDK 或者一个容器已提供该依赖之后才使用， provided 依赖在编译和测试时需要，在运行时不需要，比如：servlet api 被 tomcat 容器提供。 runtime：runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如：jdbc的驱动包。由于运行时需要所以 runtime 范围的依赖会被打包。 test：test 范围依赖 在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用，比如：junit。由于运行时不需要所以 test范围依赖不会被打包。 system：system 范围依赖与 provided 类似，但是你必须显式的提供一个对于本地系统中 JAR文件的路径，需要指定 systemPath 磁盘路径，system依赖不推荐使用。 TOMCAT解压即可使用，配置文件在D:\\apache-tomcat\\apache-tomcat-8.5.31\\conf中","categories":[],"tags":[],"keywords":[]},{"title":"面向对象特性：继承 封装 多态 抽象","slug":"javase","date":"2019-07-12T14:29:09.000Z","updated":"2019-07-12T15:52:54.156Z","comments":true,"path":"2019/07/12/javase/","link":"","permalink":"http://yoursite.com/2019/07/12/javase/","excerpt":"","text":"面向对象特性：继承 封装 多态 抽象 基本数据类型：整型、浮点、字符、布尔 引用类型：String等 int范围： 12341、java中int的取值范围为-2147483648到+-2147483648。2、首先jdk中定义int占4个字节32位，32位就是jvm仅仅给分配32个格子的空间，用以存放数据。3、计算机中用0和1存放数据。那么，32个格子中放满0或1的方法，有2的32次方种。4、但是java中int有正负之分，所以32个格子中占用一个格子标识正负，仅仅能用31个格子来标识数值。最后int能标识的最大/最小数字是：2的31次方即+/- 2147483648。取值范围即为二者之间。 集合 List 和 Set 是存储单列数据的集合，Map 是存储键和值这样的双列数据的集合；List 中存储的数据是有顺序，并且允许重复；Map 中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的，Set 中存储的数据是无序的，且不允许有重复，但元素在集合中的位置由元素的 hashcode 决定，位置是固定的（Set 集合根据 hashcode 来进行数据的存储，所以位置是固定的，但是位置不是用户可以控制的，所以对于用户来说 set 中的元素还是无序的） List接口下实现类： 1234567LinkedList：基于链表实现，链表增删快，查找慢ArrayList：：基于数组实现，非线程安全的，效率高，便于索引，但不便于插入删除Vector：基于数组实现，线程安全的，效率低ArrayList 底层结构是数组,底层查询快,增删慢。LinkedList 底层结构是链表型的,增删快,查询慢。voctor 底层结构是数组 线程安全的,增删慢,查询慢。 Map： 1234HashMap：基于 hash 表的 Map 接口实现，非线程安全，高效，支持 null键值；HashTable：线程安全，低效，不支持 null 值和 null 键；LinkedHashMap：是 HashMap 的一个子类，保存了记录的插入顺序ConcurrentHashMap：HashTable的替代品，ConcurrentHashMap与HashTable都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。 Set 接口： 12HashSet：底层是由HashMap实现，不允许集合中有重复的值，使用该方式时需要重写 equals()和 hashCode()方法LinkedHashSet：继承与 HashSet，同时又基于 LinkedHashMap 来进行实现，底层使用的是 LinkedHashMap） List a=new ArrayList()和 ArrayList a =new ArrayList()的区别1List list = new ArrayList();这句创建了一个ArrayList的对象后把上溯到了List。此时它是一个 List 对象了，有些ArrayList 有但是 List 没有的属性和方法，它就不能再用了。而 ArrayList list=new ArrayList();创建一对象则保留了ArrayList 的所有属性。 所以需要用到 ArrayList 独有的方法的时候不能用前者 Java 中 ArrayList 和 Linkedlist 区别多系统服务器交互1、两个项目同时访问一个数据库的中间库，触发器分发数据库到项目数据库中 2、使用webservice接口实现 Oracle中存储过程优点：存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般SQL语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。当对数据库进行复杂操作时(如对多个表进行Update、Insert、Query、Delete时），可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。3.存储过程可以重复使用,可减少数据库开发人员的工作量。4.安全性高,可设定只有某用户才具有对指定存储过程的使用权。 类与接口区别1234561、接口类似于类，但接口的成员都没有执行方式，它只是方法、属性、事件和索引的组合而已，并且也只能包含这四种成员；类除了这四种成员之外还可以有别的成员(如字段)。2、不能实例化一个接口，接口只包括成员的签名；而类可以实例化(abstract类除外)。3、接口没有构造函数，类有构造函数。4、接口不能进行运算符的重载，类可以进行运算符重载。5、接口的成员没有任何修饰符，其成员总是公共的，而类的成员则可以有修饰符(如：虚拟或者静态)。6、派生于接口的类必须实现接口中所有成员的执行方式，而从类派生则不然。 获取日期时间1234567891011121314Calendar cal = Calendar.getInstance(); //获取日历实例System.out.println(cal.get(Calendar.YEAR));System.out.println(cal.get(Calendar.MONTH)); // 0 - 11System.out.println(cal.getTime()); //获取当前时间 格式化// Java 8LocalDateTime dt = LocalDateTime.now(); //通过LDT now()方法获取当前时间实例System.out.println(dt.getYear()); System.out.println(dt.getMonthValue()); // 1 - 12System.out.println(dt.getDayOfMonth());System.out.println(dt.getHour());System.out.println(Clock.systemDefaultZone().millis()); //当前时间戳System.out.println(Clock.systemDefaultZone().getZone()); //获取时区 如何将一个 java 对象序列化到文件里12345678910111. //对象输出流2. ObjectOutputStream objectOutputStream = 3. new ObjectOutputStream(new FileOutputStream(new File(\"D://obj\")));4. objectOutputStream.writeObject(new User(\"zhangsan\", 100));5. objectOutputStream.close();6. //对象输入流7. ObjectInputStream objectInputStream = 8. new ObjectInputStream(new FileInputStream(new File(\"D://obj\")));9. User user = (User)objectInputStream.readObject();10. System.out.println(user);11. objectInputStream.close(); java导出excel图表等POI开源组件实现将数据导出到Excel文件中 如果 cookie 被禁用了怎么办保持登录的关键不是 cookie，而是通过cookie 保存和传输的 session ID，其本质是能获取用户信息的数据。除了 cookie，还通常使用 HTTP 请求头来传输。但是这个请求头浏览器不会像 cookie 一样自动携带，需要手工处理 设计模式1234创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式 单例设计模式123456789饿汉式：// 直接创建对象// 私有化构造函数// 返回对象实例懒汉式：// 声明变量// 私有构造函数// 提供对外方法 工厂方法模式1234工厂方法模式分为三种：普通工厂模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。多个工厂方法模式，是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可","categories":[],"tags":[],"keywords":[]},{"title":"小兵","slug":"小兵","date":"2019-07-12T14:29:09.000Z","updated":"2019-07-12T14:34:39.341Z","comments":true,"path":"2019/07/12/小兵/","link":"","permalink":"http://yoursite.com/2019/07/12/小兵/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"hello","slug":"hello","date":"2019-02-14T17:02:38.000Z","updated":"2019-02-14T17:02:38.090Z","comments":true,"path":"2019/02/15/hello/","link":"","permalink":"http://yoursite.com/2019/02/15/hello/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"vmware安装与激活","date":"2019-02-14T17:00:49.055Z","updated":"2018-11-13T07:46:37.619Z","comments":true,"path":"2019/02/15/vmware安装与激活/","link":"","permalink":"http://yoursite.com/2019/02/15/vmware安装与激活/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"idea环境配置","date":"2019-02-14T17:00:49.006Z","updated":"2018-12-13T12:19:14.973Z","comments":true,"path":"2019/02/15/idea环境配置/","link":"","permalink":"http://yoursite.com/2019/02/15/idea环境配置/","excerpt":"","text":"安装与环境正常安装，选择电脑位数版本 首次不导入设置 创建工程设置sdk选择 Create New Project,点击 new 按钮，配置安装的 JDK版本,选择 JDK目录，点击确定 一直下一步，创建项目名 IDEA的工作界面，我们的项目已经创建好了，如果再新建项目，点击 File-&gt;new-&gt;Project 字体设置点击菜单栏上的 File-&gt;Settings-&gt;Editor-&gt;Font 修改字体。 项目目录.idea 目录和 demo.iml 和我们开发无关，是IDEA工具自己使用的out 目录是存储编译后的.class文件src 目录是存储我们编写的.java源文件 Maven配置设置maven仓库 其他配置配置编码 配置jdk 配置快捷键可以选择模板，自定义请先copy个副本 设置idea导入包（多个同名的类调用不同的包，必须自己手动Alt+Enter设置） 自定义自己代码模板 提示忽略大小写默认idea设置是区分大小写的，可以设置关闭 配置虚拟机内存123456修改idea64.exe.vmoptions（64位电脑选择此文件）一个例子，电脑内存8G，设置如下：-Xms1024m-Xmx4096m-XX:MaxPermSize=1024m-XX:ReservedCodeCacheSize=1024m 设置配置编码问题修改idea64.exe.vmoptions 1-Dfile.encoding=UTF8 IDEA常用快捷键12345678910快捷键 功能Alt+Enter 导入包，自动修正代码Ctrl+Y 删除光标所在行Ctrl+D 复制光标所在行的内容，插入光标位置下面Ctrl+Alt+L 格式化代码Ctrl+/ 单行注释Ctrl+Shift+/ 选中代码注释，多行注释，再按取消注释Alt+Ins 自动生成代码，toString，get，set等方法Alt+Shift+上下箭头 移动当前代码行Ctrl+空格 补全代码 自定义设置快捷键部分快捷键冲突，例如Ctrl+空格，因此需要手动修改 File-&gt;Settings-&gt;keymap-&gt;Main menu-&gt;code-&gt;Completion-&gt;Basic 双击 Basic-&gt;remove-&gt;Ctrl+空格再次双击 Basic-&gt;Add Keyboard-&gt;键入 Alt+/-&gt;点击OK","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"Vue","date":"2019-02-14T16:54:38.211Z","updated":"2018-12-13T12:19:22.679Z","comments":true,"path":"2019/02/15/Vue/","link":"","permalink":"http://yoursite.com/2019/02/15/Vue/","excerpt":"","text":"Vue1 vue简介Vue (读音 /vju/，类似于 view) 是一套用于构建用户界面的渐进式框架。和AngularJS的语法非常的相似。 Vue 的一些语法和 AngularJS 的很相似 (例如 v-if vs ng-if)。因为 AngularJS 是 Vue 早期开发的灵感来源。然而，AngularJS 中存在的许多问题，在 Vue 中已经得到解决。 1.1 MVVM模式MVVM模式： M ： Model (数据) V ：View（视图）–静态页面 VM ：vue 的实例 1234567const vm = new Vue(&#123; // this ---》 当前的 VM的实例 el:\"#id\", // id任意即可 data:&#123; message:\"hello...\" &#125;&#125;) 2 Vue常用的指令2.1 插值表达式1&#123;&#123; message &#125;&#125; // 表达式内可以 写算术运算， 调用vue的方法， 但是不可以定义 js的变量等 2.2 v-onv-on:click , v-on:keydown 和原生js 一样的，vue给我们提供简写的方式 @click, 绑定事件的处理 2.3 v-text 和 v-html 和 v-bindv-text: 绑定的数据是文本 v-html: 显示带HTML代码的数据， 也可以显示存文本 v-bind: 强制绑定HTML标签的属性上， 简写： 如：v-bind:href=”url” ， 简写 :href=”url” 简写: 2.4 v-model绑定表单中得HTML的变量 你可以用 v-model 指令在表单 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt; 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 2.5 v-forv-for： 循环遍历 ， 字符串数组， 遍历对象， 集合… es6中要加冒号后面写唯一值即可 1v-for=\"(item, index) in list \" :key=\"index\" 2.6 v-if 和 v-show判断是否显示当前的变量的值， 如果条件成立，显示， 否则不显示 3 Vue生命周期 8个分为三大类： 初始化方法（四个）只会调用一次 更新显示（循环） 销毁VM实例 4 axios异步调用参考官网","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"nodeJS","date":"2019-02-14T16:54:38.183Z","updated":"2018-11-12T11:52:19.000Z","comments":true,"path":"2019/02/15/nodeJS/","link":"","permalink":"http://yoursite.com/2019/02/15/nodeJS/","excerpt":"","text":"第1章 NodeJS1 学习目标： 掌握Node.js基本使用方法，理解模块化编程 掌握包资源管理器NPM的使用 说出webpack的作用 掌握ES6常用的新特性语法 2 Node.js2.1 什么是Node.js简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 2.2 Node.js安装1、下载对应你系统的Node.js版本: https://nodejs.org/en/download/ （我们现在使用的版本是v9.4.0，资源中也已提供）2、选安装目录进行安装 默认即可 3.测试 在命令提示符下输入命令 1node -v 会显示当前node的版本 2.3 快速入门2.3.1 控制台输出我们现在做个最简单的小例子，演示如何在控制台输出，创建文本文件demo1.js,代码内容 123var a=1;var b=2;console.log(a+b); 我们在命令提示符下输入命令 1node demo1.js 2.3.2 使用函数创建文本文件demo2.js 12345var c=add(100,200);console.log(c);function add(a,b)&#123; return a+b;&#125; 命令提示符输入命令 1node demo2.js 运行后看到输出结果为300 2.3.3 模块化编程创建文本文件demo3_1.js 123exports.add=function(a,b)&#123; return a+b;&#125; 创建文本文件demo3_2.js，3.1赋值给demo然后直接调用 12var demo= require('./demo3_1');console.log(demo.add(400,600)); 我们在命令提示符下输入命令 1node demo3_2.js 结果为1000 2.3.4 创建web服务器创建文本文件demo4.js 1234567891011var http = require('http');http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 发送响应数据 \"Hello World\" response.end('Hello World\\n');&#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); http为node内置的web模块 我们在命令提示符下输入命令 1node demo4.js 服务启动后，我们打开浏览器，输入网址 \u0003http://localhost:8888/ 即可看到网页输出结果Hello World 心情是不是很激动呢？Ctrl+c 终止运行。 2.3.5 理解服务端渲染我们创建demo5.js ，将上边的例子写成循环的形式 1234567891011121314var http = require('http');http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 发送响应数据 \"Hello World\" for(var i=0;i&lt;10;i++)&#123; response.write('Hello World\\n'); &#125; response.end(''); &#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 我们在命令提示符下输入命令启动服务 1node demo5.js 浏览器地址栏输入http://127.0.0.1:8888即可看到查询结果。 我们右键“查看源代码”发现，并没有我们写的for循环语句，而是直接的10条Hello World ，这就说明这个循环是在服务端完成的，而非浏览器（客户端）来完成。这与我们原来的JSP很是相似。 2.3.6 接收参数创建demo6.js 1234567891011var http = require('http');var url = require('url');http.createServer(function(request, response)&#123; response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 解析 url 参数 var params = url.parse(request.url, true).query; response.write(\"name:\" + params.name); response.write(\"\\n\"); response.end();&#125;).listen(8888);console.log('Server running at http://127.0.0.1:8888/'); 我们在命令提示符下输入命令 1node demo6.js 在浏览器测试结果 3 包资源管理器NPM3.1 什么是NPMnpm全称Node Package Manager，他是node包管理和分发工具。其实我们可以把NPM理解为前端的Maven 我们通过npm 可以很方便地下载js库，管理前端工程. 最新版本的node.js已经集成了npm工具，在命令提示符输入 npm -v 可查看当前npm版本 3.2 NPM命令3.2.1 初始化工程init命令是工程初始化命令。 建立一个空文件夹，在命令提示符进入该文件夹 执行命令初始化 1npm init 按照提示输入相关信息，如果是用默认值则直接回车即可。 name: 项目名称 version: 项目版本号 description: 项目描述 keywords: {Array}关键词，便于用户搜索到我们的项目 最后会生成package.json文件，这个是包的配置文件，相当于maven的pom.xml 我们之后也可以根据需要进行修改。 3.2.2 本地安装install命令用于安装某个模块，如果我们想安装express模块（node的web框架），输出命令如下： 1npm install express 出现黄色的是警告信息，可以忽略，请放心，你已经成功执行了该命令。 在该目录下已经出现了一个node_modules文件夹 和package-lock.json node_modules文件夹用于存放下载的js库（相当于maven的本地仓库） package-lock.json是当 node_modules 或 package.json 发生变化时自动生成的文件。这个文件主要功能是确定当前安装的包的依赖，以便后续重新安装的时候生成相同的依赖，而忽略项目开发过程中有些依赖已经发生的更新。 我们再打开package.json文件，发现刚才下载的express已经添加到依赖列表中了. 关于版本号定义： 1234567指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。latest：安装最新版本。 3.2.3 全局安装刚才我们使用的是本地安装，会将js库安装在当前目录，而使用全局安装会将库安装到你的全局目录下。 如果你不知道你的全局目录在哪里，执行命令 1npm root -g 我的全局目录在 C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules 比如我们全局安装jquery, 输入以下命令 1npm install jquery -g 3.2.4 批量下载我们从网上下载某些代码，发现只有package.json,没有node_modules文件夹，这时我们需要通过命令重新下载这些js库. 进入目录（package.json所在的目录）输入命令 1npm install 此时，npm会自动下载package.json中依赖的js库. 3.2.5淘宝NPM镜像【建议使用】有时我们使用npm下载资源会很慢，所以我们可以安装一个cnmp(淘宝镜像)来加快下载速度。 输入命令，进行全局安装淘宝镜像。 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装后，我们可以使用以下命令来查看cnpm的版本 1cnpm -v 使用cnpm 1cnpm install 需要下载的js库 3.2.6 运行工程如果我们想运行某个工程，则使用run命令 如果package.json中定义的脚本如下 dev是开发阶段测试运行 build是构建编译工程 lint 是运行js代码检测 我们现在来试一下运行dev 1npm run dev 3.2.7 编译工程我们接下来，测试一个代码的编译.编译后我们就可以将工程部署到nginx中啦~ 编译后的代码会放在dist文件夹中，首先我们先删除dist文件夹中的文件,进入命令提示符输入命令 1npm run build 生成后我们会发现只有个静态页面，和一个static文件夹 这种工程我们称之为单页Web应用（single page web application，SPA），就是只有一张Web页面的应用，是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。 这里其实是调用了webpack来实现打包的，关于webpack我们后续的章节进行介绍 4 Webpack4.1 什么是Webpack​ Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 ​ 从图中我们可以看出，Webpack 可以将多种静态资源 js、css、less 转换成一个静态文件，减少了页面的请求。 接下来我们简单为大家介绍 Webpack 的安装与使用 4.2 Webpack安装全局安装 12npm install webpack -gnpm install webpack-cli -g 安装后查看版本号 1webpack -v 4.3 快速入门4.3.1 JS打包（1）创建src文件夹，创建bar.js 传入什么输出什么 123exports.info=function(str)&#123; document.write(str);&#125; （2）src下创建logic.js 计算两数字之和 123exports.add=function(a,b)&#123; return a+b;&#125; （3）src下创建main.js 123var bar= require('./bar');var logic= require('./logic');bar.info( 'Hello world!'+ logic.add(100,200)); （4）创建配置文件webpack.config.js ，该文件与src处于同级目录 12345678var path = require(\"path\");module.exports = &#123; entry: './src/main.js', output: &#123; path: path.resolve(__dirname, './dist'), filename: 'bundle.js' &#125;&#125;; 以上代码的意思是：读取当前目录下src文件夹中的main.js（入口文件）内容，把对应的js文件打包，打包后的文件放入当前目录的dist文件夹下，打包后的js文件名为bundle.js （5）执行编译命令 1webpack 执行后查看bundle.js 会发现里面包含了上面两个js文件的内容 （7）创建index.html ,引用bundle.js 12345678&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"dist/bundle.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 测试调用index.html，会发现有内容输出 4.3.2 CSS打包（1）安装style-loader和 css-loader Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。 Loader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 require 来加载任何类型的模块或文件，比如 CoffeeScript、 JSX、 LESS 或图片。首先我们需要安装相关Loader插件，css-loader 是将 css 装载到 javascript；style-loader 是让 javascript 认识css 1cnpm install style-loader css-loader --save-dev （2）修改webpack.config.js 12345678910111213141516var path = require(\"path\");module.exports = &#123; entry: './src/main.js', output: &#123; path: path.resolve(__dirname, './dist'), filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125; ] &#125;&#125;; （3）在src文件夹创建css文件夹,css文件夹下创建css1 123body&#123; background:red;&#125; （4）修改main.js ，引入css1.css 1require(&apos;./css1.css&apos;); （5）重新运行webpack （6）运行index.html看看背景是不是变成红色啦？ 5 ES65.1 什么是ES6编程语言JavaScript是ECMAScript的实现和扩展 。ECMAScript是由ECMA（一个类似W3C的标准组织）参与进行标准化的语法规范。ECMAScript定义了： 语言语法 – 语法解析规则、关键字、语句、声明、运算符等。 类型 – 布尔型、数字、字符串、对象等。 原型和继承 内建对象和函数的标准库 – JSON、Math、数组方法、对象自省方法等。 ECMAScript标准不定义HTML或CSS的相关功能，也不定义类似DOM（文档对象模型）的Web API，这些都在独立的标准中进行定义。ECMAScript涵盖了各种环境中JS的使用场景，无论是浏览器环境还是类似node.js的非浏览器环境。 ECMAScript标准的历史版本分别是1、2、3、5。 那么为什么没有第4版？其实，在过去确实曾计划发布提出巨量新特性的第4版，但最终却因想法太过激进而惨遭废除（这一版标准中曾经有一个极其复杂的支持泛型和类型推断的内建静态类型系统）。 ES4饱受争议，当标准委员会最终停止开发ES4时，其成员同意发布一个相对谦和的ES5版本，随后继续制定一些更具实质性的新特性。这一明确的协商协议最终命名为“Harmony”，因此，ES5规范中包含这样两句话 ECMAScript是一门充满活力的语言，并在不断进化中。 未来版本的规范中将持续进行重要的技术改进 2009年发布的改进版本ES5，引入了Object.create()、Object.defineProperty()、getters和setters、严格模式以及JSON对象。 ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，2015年6月正式发布。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 5.2 Node.js中使用ES6ES6+ 太棒了,但是很多高级功能node是不支持的,就需要使用babel转换成ES5 （1）babel转换配置,项目根目录添加.babelrc 文件 123&#123; \"presets\" : ['es2015']&#125; （2）安装es6转换模块 1cnpm install babel-preset-es2015 --save-dev （3）全局安装命令行工具 1cnpm install babel-cli -g （4）使用 1babel-node js文件名 5.3 语法新特性5.3.1 变量声明let【重要】我们都是知道在ES6以前，var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部(不在函数内即在全局作用域的最顶部)。这就是函数变量提升例如 1234567function aa() &#123; if(bool) &#123; var test = 'hello man' &#125; else &#123; console.log(test) &#125;&#125; 以上的代码实际上是: 12345678910function aa() &#123; var test // 变量提升 if(bool) &#123; test = 'hello man' &#125; else &#123; //此处访问test 值为undefined console.log(test) &#125; //此处访问test 值为undefined &#125; 所以不用关心bool是否为true or false。实际上，无论如何test都会被创建声明。 接下来ES6主角登场： 我们通常用let和const来声明，let表示变量、const表示常量。let和const都是块级作用域。怎么理解这个块级作用域？在一个函数内部 ，在一个代码块内部。看以下代码 12345678function aa() &#123; if(bool) &#123; let test = 'hello man' &#125; else &#123; //test 在此处访问不到 console.log(test) &#125; &#125; 5.3.2 常量声明const 用于声明常量，看以下代码 12const name = 'lux'name = 'joe' //再次赋值此时会报错 5.3.3 模板字符串es6模板字符简直是开发者的福音啊，解决了ES5在字符串功能上的痛点。 第一个用途，基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定。 123456//es5 var name = 'lux'console.log('hello' + name )//es6const name = 'lux'console.log(`hello $&#123;name&#125;`) //hello lux 第二个用途，在ES5时我们通过反斜杠()来做多行字符串或者字符串一行行拼接。ES6反引号()直接搞定。 1234567// es5var msg = \"Hi \\man!\"// es6const template = `&lt;div&gt; &lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;` 5.3.4 函数默认参数ES6为参数提供了默认值。在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。 看例子代码 12345function action(num = 200) &#123; console.log(num)&#125;action() //200action(300) //300 5.3.5 箭头函数【重点】ES6很有意思的一部分就是函数的快捷写法。也就是箭头函数。 箭头函数最直观的三个特点。 1不需要function关键字来创建函数 2省略return关键字 3继承当前上下文的 this 关键字 看下面代码（ES6） 123(response,message) =&gt; &#123; .......&#125; 相当于ES5代码 123function(response,message)&#123; ......&#125; 5.3.6 对象初始化简写ES5我们对于对象都是以键值对的形式书写，是有可能出现键值对重名的。例如 123456function people(name, age) &#123; return &#123; name: name, age: age &#125;; &#125; 以上代码可以简写为 123456function people(name, age) &#123; return &#123; name, age &#125;; &#125; 5.3.7 解构数组和对象是JS中最常用也是最重要表示形式。为了简化提取信息，ES6新增了解构，这是将一个数据结构分解为更小的部分的过程 ES5我们提取对象中的信息形式如下 1234567const people = &#123; name: 'lux', age: 20&#125;const name = people.nameconst age = people.ageconsole.log(name + ' --- ' + age) 是不是觉得很熟悉，没错，在ES6之前我们就是这样获取对象信息的，一个一个获取。现在，ES6的解构能让我们从对象或者数组里取出数据存为变量，例如 123456789101112//对象 const people = &#123; name: 'lux', age: 20 &#125; const &#123; name, age &#125; = people console.log(`$&#123;name&#125; --- $&#123;age&#125;`) //数组 const color = ['red', 'blue'] const [first, second] = color console.log(first) //'red' console.log(second) //'blue' 5.3.8 Spread OperatorES6中另外一个好玩的特性就是Spread Operator 也是三个点儿…接下来就展示一下它的用途。 组装对象或者数组 123456789//数组const color = ['red', 'yellow']const colorful = [...color, 'green', 'pink']console.log(colorful) //[red, yellow, green, pink]//对象const alp = &#123; fist: 'a', second: 'b'&#125;const alphabets = &#123; ...alp, third: 'c' &#125;console.log(alphabets) //&#123; \"fist\": \"a\", \"second\": \"b\", \"third\": \"c\" 5.3.9 import 和 export【重点】import导入模块、export导出模块 lib.js 123456789101112131415161718let fn0=function()&#123; console.log('fn0...');&#125;export &#123;fn0&#125;let dele=function()&#123; console.log('dele...');&#125;export &#123;dele&#125;// 还可以写成export default &#123; fn0()&#123; console.log('fn0...'); &#125;, dele()&#123; // .... &#125;&#125; demo9.js 1234567891011import &#123;fn0&#125; from './lib'import &#123;dele&#125; from './lib'fn0();// 还可以写成// 1.import * as jsApi from './lib.js' // 后缀可以省略jsApi.info()jsApi.dele()// 2.import jsApi from './lib.js' // 使用这种方式 ，必须要使用export default &#123;&#125; 导出 注意：node(v8.x)本身并不支持import关键字，所以我们需要使用babel的命令行工具来执行（配置详见6.2小节内容） 1babel-node demo9 5.3.10 Promise（自学内容）​ Promise 是异步编程的一种解决方案，比传统的解决方案–回调函数和事件－－更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了语法，原生提供了Promise. ​ 此知识点属于本章自学内容，请同学们百度promise查阅文章完成自学（完成测试代码，整理自学笔记）。","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"Java日志文件的八个级别","date":"2019-02-14T16:54:38.135Z","updated":"2018-11-25T08:22:10.143Z","comments":true,"path":"2019/02/15/Java日志文件的八个级别/","link":"","permalink":"http://yoursite.com/2019/02/15/Java日志文件的八个级别/","excerpt":"","text":"通常： 项目开发阶段用Info，运营阶段用Error 详细： log4j定义了8个级别的log（除去OFF和ALL，可以说分为6个级别），优先级从高到低依次为：OFF、FATAL、ERROR、WARN、INFO、DEBUG、TRACE、 ALL。 ALL 最低等级的，用于打开所有日志记录。 TRACE designates finer-grained informational events than the DEBUG.Since:1.2.12，很低的日志级别，一般不会使用。 DEBUG 指出细粒度信息事件对调试应用程序是非常有帮助的，主要用于开发过程中打印一些运行信息。 INFO 消息在粗粒度级别上突出强调应用程序的运行过程。打印一些你感兴趣的或者重要的信息，这个可以用于生产环境中输出程序运行的一些重要信息，但是不能滥用，避免打印过多的日志。 WARN 表明会出现潜在错误的情形，有些信息不是错误信息，但是也要给程序员的一些提示。 ERROR 指出虽然发生错误事件，但仍然不影响系统的继续运行。打印错误和异常信息，如果不想输出太多的日志，可以使用这个级别。 FATAL 指出每个严重的错误事件将会导致应用程序的退出。这个级别比较高了。重大错误，这种级别你可以直接停止程序了。 OFF 最高等级的，用于关闭所有日志记录。 如果将log level设置在某一个级别上，那么比此级别优先级高的log都能打印出来。例如，如果设置优先级为WARN，那么OFF、FATAL、ERROR、WARN 4个级别的log能正常输出，而INFO、DEBUG、TRACE、 ALL级别的log则会被忽略。Log4j建议只使用四个级别，优先级从高到低分别是ERROR、WARN、INFO、DEBUG。 从我们实验的结果可以看出，log4j默认的优先级为ERROR或者WARN（实际上是ERROR）。 使用 例如使用ERROR级别，就不会生成WARN INFO等详细异常。","categories":[],"tags":[],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2019-02-14T16:37:47.004Z","updated":"2019-02-14T16:37:47.006Z","comments":true,"path":"2019/02/15/hello-world/","link":"","permalink":"http://yoursite.com/2019/02/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}